# GENERATED BY WSCITE_API.XSL   DO NOT EDIT BY HAND!
_IntelDebugNext( UnknownType  ) RETURNS: void =>Plays the next intel event in the debug queue. IntelEvents are played sequentially as they are defined in a mission's .events file. 
_IntelDebugPrev( UnknownType  ) RETURNS: void =>Plays the next intel event in the debug queue. IntelEvents are played sequentially as they are defined in a mission's .events file. 
_IntelDebugReplay( UnknownType  ) RETURNS: void =>Replays the last intel event that was debugged. 
Actor_Clear( ActorTable actor ) RETURNS: Void =>Clear ties between an actor and any units. 
Actor_PlaySpeech( ActorTable actor, Integer locID, Boolean continueButton, Boolean stickySubtitle, Boolean blockInput ) RETURNS: Void =>Plays a speech event for a given actor WITH a portrait and subtitle. 
Actor_PlaySpeechWithoutPortrait( ActorTable actor, Integer locID, Boolean continueButton, Boolean stickySubtitle, Boolean blockInput ) RETURNS: Void =>Plays a speech event for a given actor WITHOUT a portrait or subtitle. See Actor_PlaySpeech for more details. 
Actor_SetFromSGroup( ActorTable actor, SGroupID sgroup ) RETURNS: Void =>Tie an entire sgroup to an actor, so audio comes from a squad member. 
Actor_SetFromSquad( ActorTable actor, SquadID squad ) RETURNS: Void =>Tie a single squad to an actor, so audio comes from a squad member. 
AIObjective_Notify_SetFailureCallback( AIObjective * pObjective, LuaConfig::RefFunction f ) RETURNS: void =>Sets the failure notification callback for objective. 
AIObjective_Notify_SetOnTransitionCallback( AIObjective * pObjective, LuaConfig::RefFunction f ) RETURNS: void =>Sets the transition notification callback for objective. 
AIObjective_Notify_SetSuccessCallback( AIObjective * pObjective, LuaConfig::RefFunction f ) RETURNS: void =>Sets the success notification callback for objective. 
AIPlayer_GetBestClumpForSquadIdx( AIPlayer * pPlayer, AISquad * pSquad, const PropertyBagGroup * pAbilityPBG, float minRange, float maxRange, uint32_t targetFilterFlags ) RETURNS: int =>returns a 0-based index of the best clump of enemy squads within the given tolerance to the AI squad 
AIPlayer_GetBestClumpIdx( AIPlayer * pPlayer, const PropertyBagGroup * pAbilityPBG, float minRange, float maxRange, float clumpSelectionGlobalBestMinRatio, uint32_t targetFilterFlags ) RETURNS: int =>returns a 0-based index of the best clump of enemy squads within the given tolerance to the AI player 
AIPlayer_GetClumpPosition( AIPlayer * pPlayer, int clumpIndex, uint32_t targetFilterFlags ) RETURNS: ScarPosition =>Used for tactics; returns a "special error position" on failure that's nowhere inside the world. 
AIPlayer_GetLocal( uint32_t playerId ) RETURNS: AIPlayer * =>Returns the local AIPlayer given a PlayerId (1000-1008) 
AIPlayer_GetLocalFromPlayer( const ModPlayer * pPlayerIn ) RETURNS: AIPlayer * =>Returns the local AIPlayer given a ModPlayer pointer. 
AIPlayer_UpdateSkirmishAttackAndCaptureTasks( AIPlayer * pPlayer ) RETURNS: void =>Requests the skirmish AI to update attack objectives and capture tasks. 
AIPlayer_UpdateSkirmishPlayerAbilities( AIPlayer * pPlayer ) RETURNS: void =>Requests the skirmish AI to update player abilities. 
AIPlayer_UpdateSkirmishProduction( AIPlayer * pPlayer ) RETURNS: void =>Updates what the skirmish AI is trying to produce. 
AISquad_FindFilteredCoverCompareCurrent( AIPlayer * player, AISquad * aiSquad, float maxPathDistanceFromGoal, bool compareToCurrentCover ) RETURNS: ScarPosition =>Tries to find cover within a certain radius of a position, traveling a max distance to get there, and possibly comparing against current position's cover. If no cover is found, it returns an invalid position. 
AISquad_GetClosestCuttableObstruction( AISquad * pSquad, float radius ) RETURNS: Entity * =>Returns the closest cuttable obstruction entity to the given squad. 
AISquad_GetClosestObstruction( AISquad * pSquad, float radius, bool bFilterAllied ) RETURNS: Entity * =>Returns the closest obstruction entity to the given squad. 
AISquad_GetClosestObstructionOfType( AISquad * pSquad, float radius, const PropertyBagGroup * pbgtype ) RETURNS: Entity * =>Returns the closest obstruction entity to the given squad. 
AISquad_HasBeenAttacked( AISquad * pAISquad, size_t historyTicks ) RETURNS: bool =>Checks if the squad has been attacked within this time. 
AISquad_HasFiredWeapon( AISquad * pAISquad, size_t historyTicks ) RETURNS: bool =>Checks if the squad has fired its weapon within this time. 
AITargetFilterContext_GetAbilityToUse(  ) RETURNS: const PropertyBagGroup * =>Returns the Ability to use in the current AI Target Filter Context. 
AITargetFilterContext_GetRangeMax(  ) RETURNS: float =>Returns the maximum range value in the current AI Target Filter Context. 
AITargetFilterContext_GetRangeMin(  ) RETURNS: float =>Returns the minimum range value in the current AI Target Filter Context. 
AITargetFilterContext_GetSuggestedPosition(  ) RETURNS: ScarPosition =>Returns the suggested position in the current AI Target Filter Context. 
AITargetFilterContext_GetTargetEntityGroup(  ) RETURNS: EGroup * =>Returns the Entity Group in the current AI Target Filter Context. 
AITargetFilterContext_GetTargetSquadGroup(  ) RETURNS: SGroup * =>Returns the Squad Group in the current AI Target Filter Context. 
AutoCinematic( Boolean in/ out, Real seconds ) RETURNS: Void =>Toggles all cinematic related settings. true = go to cinematic, false = go back to normal. 
AutoReinforce_AddSGroup( SGroupID sgroup, Variable origin ) RETURNS: Void =>Adds an SGroup to the auto-reinforce functions. 
AutoReinforce_RemoveAll( Void  ) RETURNS: Void =>Stops monitoring all squads from the auto-reinforce functions. 
AutoReinforce_RemoveSGroup( SGroupID sgroup ) RETURNS: Void =>Removes an SGroup from the auto-reinforce functions. 
AutoRetreat_AddSGroup( SGroupID sgroup, MarkerID/Position/EGroupID destination, Real threshold, LuaFunction onTrigger ) RETURNS: Void =>Sets an sgroup to retreat to the given destination or building once pinned for a certain duration, or reduced to a third of it's original size. 
AutoRetreat_RemoveAll( Void  ) RETURNS: Void =>Stops monitoring all squads from the auto-retreat functions. 
AutoRetreat_RemoveSGroup( SGroupID sgroup ) RETURNS: Void =>Removes a squad from being monitored by the auto-retreat functions. 
BeginnerHint_AddOpportunity( Pos/Group/Table where, AbilityID/Table ability, Bool repeating, LocText message, String icon, HPAT arrow, GD max_difficulty, Bool ignore_timers ) RETURNS: OpportunityID =>Add an opportunity that may get highlighted by the hint manager system on easier difficulty modes. THIS IS NOT MP-SAFE! 
BeginnerHint_AddOpportunity( Pos/Group/Table where, AbilityID/Table ability, Bool repeating, LocText message, String icon, HPAT arrow, GD max_difficulty, Bool ignore_timers ) RETURNS: OpportunityID =>Add an opportunity that may get highlighted by the hint manager system on easier difficulty modes. THIS IS NOT MP-SAFE! 
BeginnerHint_RemoveAllOpportunities( Void  ) RETURNS: Void =>Remove all opportunities in one fell swoop! 
BeginnerHint_RemoveAllOpportunities( Void  ) RETURNS: Void =>Remove all opportunities in one fell swoop! 
BeginnerHint_RemoveOpportunity( Pos/OpportunityID where ) RETURNS: Void =>Remove an opportunity, either by ID or all opportunities at a location. 
BeginnerHint_RemoveOpportunity( Pos/OpportunityID where ) RETURNS: Void =>Remove an opportunity, either by ID or all opportunities at a location. 
BP_GetAbilityBlueprint( const char * pbgShortname ) RETURNS: ScarAbilityPBG =>Returns an ability property bag group. 
BP_GetCamouflageStanceBlueprint( const char * pbgShortname ) RETURNS: ScarCamouflageStancePBG =>Returns a camouflage stance property bag group. 
BP_GetCriticalBlueprint( const char * pbgShortname ) RETURNS: ScarCriticalPBG =>Returns a critical property bag group. 
BP_GetEntityBlueprint( const char * pbgShortname ) RETURNS: ScarEntityPBG =>Returns an entity property bag group. 
BP_GetMoveTypeBlueprint( const char * pbgShortname ) RETURNS: ScarMoveTypePBG =>Returns a move type property bag group. 
BP_GetName( const PropertyBagGroup * pbg ) RETURNS: const char * =>Return the short name of the group. 
BP_GetPropertyBagGroupCount( LuaBinding::StackVar type ) RETURNS: int =>Return the number of property bag groups of the same type. 
BP_GetPropertyBagGroupPathName( LuaBinding::StackVar type, size_t index ) RETURNS: const char * =>Return the path name of the group at the specified index. 
BP_GetSlotItemBlueprint( const char * pbgShortname ) RETURNS: ScarSlotItemPBG =>Returns a slot item property bag group. 
BP_GetSquadBlueprint( const char * pbgShortname ) RETURNS: ScarSquadPBG =>Returns a squad property bag group. 
BP_GetUpgradeBlueprint( const char * pbgShortname ) RETURNS: ScarUpgradePBG =>Returns an upgrade property bag group. 
BP_GetWeaponBlueprint( const char * pbgShortname ) RETURNS: ScarWeaponPBG =>Returns a weapon property bag group. 
BridgeTerritory_Add( EGroupID bridge_egroup, EGroupID bridgepoint, EGroupID bank1point, EGroupID bank2point ) RETURNS: Void =>Add a bridge to the Bridge Territory Manager. 
Camera_CyclePositions( Table list, Boolean pan, Float panRate, ScarFn callback ) RETURNS: Void =>Moves the camera through a list of positions. 
Camera_Follow( Variable var ) RETURNS: Void =>Set the camera to follow an sgroup/squad/egroup/entity. 
Camera_MoveTo( Variable var, Boolean pan, Float panRate, Boolean keepInputLocked, Boolean resetToDefault ) RETURNS: Void =>Move the camera to an entity/marker/pos/egroup/sgroup/squad. 
Camera_MoveToIfClose( Variable var ) RETURNS: Void =>Slightly refocus the camera to rest on an entity/squad/squad/sgroup/egroup/pos/marker if it's close by. 
Camera_SetDefault( Float height, Float declination, Float angle ) RETURNS: Void =>Helper function to set the default camera parameters. 
Ceasefire_AddSGroup( SGroupID sgroup, LuaFunction function ) RETURNS: Void =>Stops an SGroup from auto-targetting, until one of their members is explicity given an attack order or Ceasefire_RemoveSGroup() is called (at which point they all start firing again) 
Ceasefire_RemoveSGroup( SGroupID sgroup ) RETURNS: Void =>Removes the ceasefire effect from an sgroup. This may already have been removed by issuing an attack order directly to the group. 
Clone( Table data ) RETURNS: Table =>Clones a table (recursively) allowing for unadulterated use of the data. 
Cmd_AbandonTeamWeapon( SGroupID sgroupid, Boolean preserveCrew, Boolean queued ) RETURNS: Void =>Order a squad group to abandon their current team weapon if they have it and they could (tuning value in attribute editor) 
Cmd_Ability( PlayerID/EGroupID/SGroupID user, AbilityBlueprint blueprint, Position/SGroupID/EGroupID target, Position direction, Bool skipCostPrereq, Bool queued ) RETURNS: Void =>Sends an ability command to a player, egroup or sgroup. extra parameters are provided if the ability requires them. 
Cmd_AttachSquads( SGroupID sgroup, SGroupID sgroupAttachee ) RETURNS: Void =>Attach the squad from sgroupnameAttachee to sgroupname. Both SGroups must contain only one squad. 
Cmd_Attack( SGroupID sgroup, SGroup/EGroup/Pos/Marker target, Boolean queued, Boolean stationary, String plan ) RETURNS: Void =>Issues an attack command to an SGroup. 
Cmd_AttackMove( SGroupID sgroup, Position targetposition, Boolean queued, String plan, Real coverSearchRadius, MarkerID deleteWhenNearMarker ) RETURNS: Void =>Order a squad group to attack move to a position (anything whose position can be queried). can be queued, can follow a plan, can search for cover within a radius. 
Cmd_AttackMoveThenCapture( SGroupID attacker, EGroupID target, Boolean queued ) RETURNS: Void =>Command attacker sgroup to attack move to strategic point target; when it is capturable, the sgroup would capture it. 
Cmd_CaptureTeamWeapon( SGroupID sgroupid, EGroupID targetid, Boolean queued ) RETURNS: Void =>Order a squad group to capture team weapon entity group. 
Cmd_Construct( SGroup sgroupid, Entity blueprint, EGroupID/Position/Marker targetid, Position Facing, Boolean queued ) RETURNS: Void =>Orders a squad to contruct a building at specified position, or to continue construction on an existing building. 
Cmd_CriticalHit( PlayerID playerid, SGroupID/EGroupID/Squad/Entity target, CriticalID criticalid, Real removeAtHealth ) RETURNS: Void =>Applies critical hit to entity/squad/sgroup/egroup. 
Cmd_DetonateDemolitions( PlayerID player, EGroupID target, Boolean queued ) RETURNS: Void =>Detonates a building's demolitions. 
Cmd_EjectOccupants( EGroupID/SGroupID fromgroupid, Position destination, Boolean queued ) RETURNS: Void =>Orders an EGroup or SGroup to kick out its occupants. If no position is specified, the occupants stay at the exit. 
Cmd_Garrison( SGroupID fromsgroupid, EGroupID/SGroupID togroupid, Bool overload, Bool queued, Bool instant ) RETURNS: EntityID =>Order a squad group to load at a random entity or squad of the group. 
Cmd_InstantReinforceUnit( SGroupID sgroup, Integer count ) RETURNS: Void =>Sends a instant reinforce command to all squads in a group. count represents the number of commands to send. 
Cmd_InstantReinforceUnitPos( SGroupID sgroup, Integer count, MarkerID/Pos spawnlocation, Integer checktype, Integer failtype ) RETURNS: Void =>Sends a instant reinforce command to all squads in a group. count represents the number of commands to send. spawnlocation is where the reinforced unit will spawn. You can optionally find a hidden position by specifying a checktype (CHECK_OFFCAMERA, CHECK_IN_FOW or CHECK_BOTH), and what to do if a hidden position can't be found (SPAWN_ATMARKER, SPAWN_ATSQUAD, or DO_NOTHING) - SPAWN_ATMARKER is the default. 
Cmd_InstantSetupTeamWeapon( SGroupID sgroupid, Boolean queued ) RETURNS: Void =>Order a squad group to instant setup their team weapon. 
Cmd_InstantUpgrade( PlayerID/EGroupID/SGroupID target, UpgradeBlueprint/Table blueprint, Integer count ) RETURNS: Void =>Sends an instant upgrade command to a player, egroup or sgroup. accepts a single upgrade or table of upgrades. 
Cmd_Move( SGroupID sgroup, Pos/SGroupID/EGroupID/MarkerID position, Boolean queued, MarkerID deleteWhenNearMarker, Position facing, Integer offset, Real distance, Real coverSearchRadius ) RETURNS: Void =>Move a squad group to a given position. 
Cmd_MoveAwayFromPos( SGroupID sgroup, Pos position, Int radius, Boolean queued ) RETURNS: Void =>Move a squad group out of a position to a certain radius. 
Cmd_MoveToAndDespawn( SGroupID sgroup, MarkerID marker, boolean queued ) RETURNS: Void =>Moves a squad group to the indicated Marker and destroys it. 
Cmd_MoveToClosestMarker( SGroupID sgroup, Table markertable ) RETURNS: markerID =>Moves a squad group to the closest marker in a list/table of MarkerIDs. 
Cmd_MoveToThenCapture( SGroupID attacker, EGroupID target, Boolean queued ) RETURNS: Void =>Command attacker sgroup to attack move to strategic point target; when it is capturable, the sgroup would capture it. 
Cmd_RecrewVehicle( SGroupID sgroupid, EGroupID targetid, Boolean queued ) RETURNS: Void =>Order a squad group to recrew an abandoned vehicle. 
Cmd_ReinforceUnit( SGroupID sgroup, Integer count ) RETURNS: Void =>Sends a reinforce command to all squads in a group. count represents the number of commands to send. 
Cmd_ReinforceUnitPos( SGroupID sgroup, Integer count, MarkerID/Pos spawnlocation, Integer checktype, Integer failtype ) RETURNS: Void =>Sends a reinforce command to all squads in a group. count represents the number of commands to send. spawnlocation is where the reinforced unit will spawn. You can optionally find a hidden position by specifying a checktype (CHECK_OFFCAMERA, CHECK_IN_FOW or CHECK_BOTH), and what to do if a hidden position can't be found (SPAWN_ATMARKER, SPAWN_ATSQUAD, or DO_NOTHING) - SPAWN_ATMARKER is the default. 
Cmd_Retreat( SGroupID sgroup, Position location, Bool/MarkerID/ScarPos deleteWhenNearMarker, Boolean queued, Boolean saveEncounters, Boolean vulnerableRetreat ) RETURNS: Void =>Order a squad group to retreat, optionally to a specific location. The sgroup can be deleted when in proximity of a marker (it assumes a proximity of 5 if you forget to set one on the marker) 
Cmd_RevertOccupiedBuilding( SGroupID sgroupid, EGroupID targetid, Boolean queued ) RETURNS: Void =>Order a squad group to revert occupied building. 
Cmd_SetDemolitions( SGroupID sgroupid, EGroupID targetid, Boolean skipCostPrereq, Boolean queued ) RETURNS: Void =>Orders a squad group to place demolition charges on a building (egroup). Function does nothing if egroup cannot be detonated, or player can't afford the demolitions. 
Cmd_SquadCamouflageStance( SGroupID sgroup, CamouflageStanceID stanceid ) RETURNS: Void =>Sends an camouflage stance command to all squads in a group. stanceid should be the number returned by Util_GetCamouflageStanceID( stancename ) 
Cmd_SquadPath( SGroupID sgroup, String pathName, Boolean bFromClosest, Integer loop, Boolean bAttackMove, Float pauseTime, MarkerID deleteWhenNearMarker, Boolean queued, Boolean bMoveForward ) RETURNS: Void =>Send a command to the squad to follow a path. Can wait at each waypoint. The sgroup can be deleted when in proximity of a marker if you pass in the marker as the 7th argument (it assumes a proximity of 5 if you forget to set one on the marker) 
Cmd_SquadPatrolMarker( SGroupID sgroup, MarkerID marker ) RETURNS: Void =>Causes a squad to patrol a marker attacking any enemies that come within its radius. If used on circular markers, the radius must be at least 5. To stop the squad from patrolling the marker, use Cmd_Stop. 
Cmd_StaggeredRetreat( SGroupID sgroup, Table markers, Integer maxTries, Boolean vulnerableRetreat ) RETURNS: Void =>Retreats large numbers of units in a staggered, realistic manner. 
Cmd_Stop( EGroupID/SGroupID group ) RETURNS: Void =>Sends a stop command to egroup or sgroup. 
Cmd_StopSquadsExcept( SGroupID sgroup1, Boolean stopCapture, Boolean stopBuild ) RETURNS: Void =>Pass in a group to command to 'stop'. Pass in booleans for capturing and building. 
Cmd_Surrender( SGroup sgroupid, Integer actionpoints, Position exitpos, Boolean deleteAtExit, Boolean removeWeapon ) RETURNS: Void =>Orders a squad to surrender and awards the local player with an appropriate number of action points. 
Cmd_UngarrisonSquad( SGroupID sgroupid, Position destination, Boolean queued ) RETURNS: Void =>Orders an sgroup to exit the building or vehicle that it's in. If no position is specified, the sgroup stays at the exit. 
Cmd_Upgrade( PlayerID/EGroupID/SGroupID user, UpgradeBlueprint/Table blueprint, Integer count, Boolean instant ) RETURNS: Void =>Sends an upgrade command to a player, egroup or sgroup. accepts a single upgrade or table of upgrades. 
Command_Entity( Player * player, EGroup * egroup, EntityCommandType entityCommand ) RETURNS: void =>Send a entity command to a entity group(CMD_DefaultAction, CMD_Stop, CMD_Destroy, CMD_BuildSquad, CMD_CancelProduction, CMD_RallyPoint, CMD_AttackForced) 
Command_EntityAbility( Player * player, EGroup * egroup, ScarAbilityPBG abilityPBG, bool skipCostAndPrereq, bool queued ) RETURNS: void =>Send an entity ability command (CMD_Ability) to an entity. 
Command_EntityBuildSquad( Player * player, EGroup * egroup, ScarSquadPBG squadPbg ) RETURNS: void =>Send a squad command to a entity group with custom data. 
Command_EntityEntity( Player * player, EGroup * egroup, EntityCommandType entityCommand, EGroup * target ) RETURNS: void =>Send a entity-based command to an entity group. 
Command_EntityExt( Player * player, EGroup * egroup, EntityCommandType entityCommand, uint32_t cmdparam, bool queued ) RETURNS: void =>Send a squad command to a squad group with custom data. 
Command_EntityPos( Player * player, EGroup * egroup, EntityCommandType entityCommand, ScarPosition target ) RETURNS: void =>Send a position command to an entity group. 
Command_EntityPosAbility( Player * player, EGroup * egroup, ScarPosition pos, ScarAbilityPBG abilityPBG, bool skipCostAndPrereq, bool queued ) RETURNS: void =>Send a positional ability command (CMD_Ability) to an entity. 
Command_EntityPosDirAbility( Player * player, EGroup * egroup, ScarPosition pos, ScarPosition dir, ScarAbilityPBG abilityPBG, bool skipCostAndPrereq, bool queued ) RETURNS: void =>Send a positional/directional ability command (CMD_Ability) to an entity. 
Command_EntityPosSquad( Player * player, EGroup * egroup, EntityCommandType entityCommand, ScarPosition target, SGroup * sgroup ) RETURNS: void =>Send a dual target (position and squad) command to an entity group. 
Command_EntitySquad( Player * player, EGroup * egroup, EntityCommandType entityCommand, SGroup * target ) RETURNS: void =>Send a squad-based command to an entity group. 
Command_EntityTargetEntityAbility( Player * player, EGroup * egroup, Entity * entityTarget, ScarAbilityPBG abilityPBG, bool skipCostAndPrereq, bool queued ) RETURNS: void =>Send an entity-targeting ability command (CMD_Ability) to an entity. 
Command_EntityTargetSquadAbility( Player * player, EGroup * egroup, Squad * squadTarget, ScarAbilityPBG abilityPBG, bool skipCostAndPrereq, bool queued ) RETURNS: void =>Send an squad-targeting ability command (CMD_Ability) to an entity. 
Command_EntityUpgrade( Player * player, EGroup * egroup, ScarUpgradePBG upgrade, bool instant, bool queued ) RETURNS: void =>Send a squad command to a entity group with custom data. 
Command_Player( Player * player, Player * dest, PlayerCommandType playerCommand ) RETURNS: void =>Send a player command to a player. 
Command_PlayerAbility( Player * player, Player * dest, ScarAbilityPBG abilityPBG, bool skipCostAndPrereq ) RETURNS: void =>Send a player ability command (PCMD_Ability) to a player. 
Command_PlayerEntity( Player * player, Player * dest, PlayerCommandType playerCommand, EGroup * target ) RETURNS: void =>Send an entity command to a player. 
Command_PlayerEntityCriticalHit( Player * player, EGroup * egroup, PlayerCommandType playerCommand, ScarCriticalPBG criticalPBG, float removeAtHealth, bool queued ) RETURNS: void =>Send a player command to itself to act upon single with custom parameter and index data (PCMD_CriticalHit) 
Command_PlayerExt( Player * player, Player * dest, PlayerCommandType playerCommand, uint32_t cmdparam, bool queued ) RETURNS: void =>Send a player command to a player with a custom flag. 
Command_PlayerPos( Player * player, Player * dest, PlayerCommandType playerCommand, ScarPosition pos ) RETURNS: void =>Send a position command to a player. 
Command_PlayerPosAbility( Player * player, Player * dest, ScarPosition pos, ScarAbilityPBG abilityPBG, bool skipCostAndPrereq ) RETURNS: void =>Send a positional ability command (PCMD_Ability) to a player. 
Command_PlayerPosDirAbility( Player * player, Player * dest, ScarPosition pos, ScarPosition dir, ScarAbilityPBG abilityPBG, bool skipCostAndPrereq ) RETURNS: void =>Send a positional/directional ability command (PCMD_Ability) to a player. 
Command_PlayerPosExt( Player * player, Player * dest, PlayerCommandType playerCommand, ScarPosition pos, uint32_t cmdparam, bool queued ) RETURNS: void =>Send a position command to a player with extra info. 
Command_PlayerSquadConstructBuilding( Player * player, SGroup * sgroup, ScarEntityPBG ebp, ScarPosition position, ScarPosition facing, bool queued ) RETURNS: void =>Send a player command to itself to order squads in the sgroup to construct the building at specific position and facing. 
Command_PlayerSquadConstructFence( Player * player, SGroup * sgroup, ScarEntityPBG ebp, ScarPosition posStart, ScarPosition posEnd, bool queued ) RETURNS: void =>Send a player command to itself to order squads in the sgroup to construct fences from posStart to posEnd. 
Command_PlayerSquadConstructField( Player * player, SGroup * sgroup, ScarEntityPBG ebp, ScarPosition posStart, ScarPosition posEnd, bool queued ) RETURNS: void =>Send a player command to itself to order squads in the sgroup to construct a field ranging from posStart to posEnd. 
Command_PlayerSquadCriticalHit( Player * player, SGroup * sgroup, PlayerCommandType playerCommand, ScarCriticalPBG criticalPBG, float removeAtHealth, bool queued ) RETURNS: void =>Send a player command to itself to act upon all entities in the sgroup with custom parameter and index data (PCMD_CriticalHit) 
Command_PlayerUpgrade( Player * player, ScarUpgradePBG upgrade, bool instant, bool queued ) RETURNS: void =>Sends an upgrade command to a player. 
Command_Squad( Player * player, SGroup * sgroup, SquadCommandType squadCommand, bool queued ) RETURNS: void =>Send a squad command to a squad group. 
Command_SquadAbility( Player * player, SGroup * sgroup, ScarAbilityPBG abilityPBG, bool skipCostAndPrereq, bool queued ) RETURNS: void =>Send a ability command (SCMD_Ability) to a squad. 
Command_SquadAttackMovePos( Player * player, SGroup * sgroup, SquadCommandType squadCommand, ScarPosition target, const char * planName, bool queued ) RETURNS: void =>Send a position ATTACK MOVE command to a squad group with custom data. 
Command_SquadDoCustomPlan( Player * player, SGroup * sgroup, const char * planFile, bool queued ) RETURNS: void =>Send a custom squad AI plan command to the squad to execute the plan specified towards the position. 
Command_SquadDoCustomPlanTarget( Player * player, SGroup * sgroup, ScarPosition pos, const char * planFile, bool queued ) RETURNS: void =>Send a custom squad AI plan command to the squad to execute the plan specified towards the position. 
Command_SquadEntity( Player * player, SGroup * sgroup, SquadCommandType squadCommand, EGroup * target, bool queued ) RETURNS: void =>Send an entity command to a squad group. 
Command_SquadEntityAbility( Player * player, SGroup * sgroup, EGroup * target, ScarAbilityPBG abilityPBG, bool skipCostAndPrereq, bool queued ) RETURNS: void =>Send a entity ability command (SCMD_Ability) to a squad. 
Command_SquadEntityAttack( Player * player, SGroup * sgroup, EGroup * target, bool bCheckFOW, bool bStationary, const char * planName, bool queued ) RETURNS: void =>Send an entity command ATTACK to a squad group. 
Command_SquadEntityBool( Player * player, SGroup * sgroup, SquadCommandType squadCommand, EGroup * target, bool cmdparam, bool queued ) RETURNS: void =>Send a entity command to a squad group with custom BOOLEAN data. 
Command_SquadEntityExt( Player * player, SGroup * sgroup, SquadCommandType squadCommand, EGroup * target, uint32_t cmdparam, bool queued ) RETURNS: void =>Send a entity command to a squad group with custom data. 
Command_SquadEntityLoad( Player * player, SGroup * sgroup, SquadCommandType squadCommand, EGroup * target, bool bOverLoad, bool queued ) RETURNS: void =>Send special squad command to a squad group with squad load parameters. 
Command_SquadExt( Player * player, SGroup * sgroup, SquadCommandType squadCommand, uint32_t cmdparam, bool queued ) RETURNS: void =>Send a squad command to a squad group with custom data. 
Command_SquadMovePos( Player * player, SGroup * sgroup, ScarPosition target, bool queued, bool reverseMove ) RETURNS: void =>Send a move to position command for a squad group. 
Command_SquadMovePosFacing( Player * player, SGroup * sgroup, ScarPosition target, ScarPosition facing, bool queued, bool reverseMove ) RETURNS: void =>Send a move-facing command to a squad group. 
Command_SquadPos( Player * player, SGroup * sgroup, SquadCommandType squadCommand, ScarPosition target, bool queued ) RETURNS: void =>Send a position command to a squad group. 
Command_SquadPosAbility( Player * player, SGroup * sgroup, ScarPosition pos, ScarAbilityPBG abilityPBG, bool skipCostAndPrereq, bool queued ) RETURNS: void =>Send a positional ability command (SCMD_Ability) to a squad. 
Command_SquadPosExt( Player * player, SGroup * sgroup, SquadCommandType squadCommand, ScarPosition target, uint32_t cmdparam, bool queued ) RETURNS: void =>Send a position command to a squad group with custom data. 
Command_SquadPositionAttack( Player * player, SGroup * sgroup, ScarPosition target, bool bCheckFOW, bool bStationary, const char * planName, bool queued ) RETURNS: void =>Send an position command ATTACK to a squad group. 
Command_SquadSquad( Player * player, SGroup * sgroup, SquadCommandType squadCommand, SGroup * target, bool queued ) RETURNS: void =>Send an squad-based command to a squad group. 
Command_SquadSquadAbility( Player * player, SGroup * sgroup, SGroup * target, ScarAbilityPBG abilityPBG, bool skipCostAndPrereq, bool queued ) RETURNS: void =>Send a squad ability command (SCMD_Ability) to a squad. 
Command_SquadSquadAttack( Player * player, SGroup * sgroup, SGroup * target, bool bCheckFOW, bool bStationary, const char * planName, bool queued ) RETURNS: void =>Send an squad-based command to a squad group. 
Command_SquadSquadExt( Player * player, SGroup * sgroup, SquadCommandType squadCommand, SGroup * target, uint32_t cmdparam, bool queued ) RETURNS: void =>Send a squad command to a squad group with custom data. 
Command_SquadSquadLoad( Player * player, SGroup * sgroup, SquadCommandType squadCommand, SGroup * target, bool bOverLoad, bool queued ) RETURNS: void =>Send special squad command to a squad group with squad load parameters. 
Command_SquadUpgrade( Player * player, SGroup * sgroup, ScarUpgradePBG upgrade, bool instant, bool queued ) RETURNS: void =>Sends an upgrade command to a squad group. 
EBP_Exists( const char * pbgShortname ) RETURNS: bool =>Returns true if an entity blueprint exists with the given name. 
EGroup_Add( EGroup * group, Entity * entity ) RETURNS: void =>Adds an entity to the end of a group if the group doesnt already have it. 
EGroup_AddEGroup( EGroup * group, EGroup * grouptoadd ) RETURNS: void =>Appends the entities in one group to another group. 
EGroup_CanSeeEGroup( EGroupID egroup, EGroupID targetegroup, Boolean all ) RETURNS: Boolean =>Returns true if ALL or ANY entities in a group can see ALL or ANY entities in a given egroup. 
EGroup_CanSeeSGroup( EGroupID egroup, SGroupID targetsgroup, Boolean all ) RETURNS: Boolean =>Returns true if ALL or ANY entities in a group can see ALL or ANY squads in a given sgroup. 
EGroup_Clear( EGroup * egroup ) RETURNS: void =>Removes all entities from a group. 
EGroup_Compare( EGroup * group1, EGroup * group2 ) RETURNS: bool =>Returns true if the contents of the two groups are equal. Order of the entities does not matter. 
EGroup_ContainsBlueprints( EGroupID egroup, BP/Table blueprint, Boolean all ) RETURNS: Boolean =>Check if a group contains ALL or ANY of the blueprints. 
EGroup_ContainsEGroup( EGroupID egroup1, EGroupID egroup2, Boolean all ) RETURNS: Boolean =>Returns true if EGroup1 contains ANY or ALL of EGroup2. 
EGroup_ContainsEntity( EGroupID egroup, EntityID entity ) RETURNS: Boolean =>Returns true if EGroup contains a particular EntityID. 
EGroup_Count( EGroup * egroup ) RETURNS: int =>Returns the total number of spawned and despawned entities in a group. 
EGroup_CountAlive( EGroupID egroup ) RETURNS: int =>Get the number of alive entities (both spawned and despawned) 
EGroup_CountDeSpawned( EGroup * egroup ) RETURNS: int =>Returns the number of despawned entities in a group. 
EGroup_CountSpawned( EGroup * egroup ) RETURNS: int =>Returns the number of spawned entities in a group. 
EGroup_Create( const char * name ) RETURNS: EGroup * =>Returns a new entity group with the given name. 
EGroup_CreateIfNotFound( String egroupname ) RETURNS: EGroupID =>Find a entity group from name. Creates a new one with given name if it doesnt exist. 
EGroup_CreateKickerMessage( EGroupID group, PlayerID , player , LocString textid ) RETURNS: Void =>Create and display kicker message on the each entity in the egroup to the player. 
EGroup_CreateTable( String format, Integer size ) RETURNS: LuaTable =>Returns a table of egroups NOT in the world builder. 
EGroup_DeSpawn( EGroupID egroup ) RETURNS: Void =>Despawn all spawned entities in a group. 
EGroup_Destroy( EGroup * egroup ) RETURNS: void =>Manually destroy a group that you dont need anymore. 
EGroup_DestroyAllEntities( EGroupID egroup ) RETURNS: Void =>Destroys all spawned and despawned entities in a group. 
EGroup_Duplicate( EGroupID egroupid1, EGroupID egroupid2 ) RETURNS: Void =>Duplicates an EGroup. 
EGroup_EnableMinimapIndicator( EGroupID egroup, Boolean enable ) RETURNS: Void =>Enables or disables the minimap indicator for all entities in a group. 
EGroup_EnableUIDecorator( SGroupID group, Boolean enable, Boolean enableSelection ) RETURNS: Void =>Enable or disable decorators on all entities in the egroup. Sets selection visuals as well unless enableSelection is specified. 
EGroup_Exists( const char * name ) RETURNS: bool =>Returns true if the entity group with the given name exists. 
EGroup_Filter( EGroupID egroup, String/ID/Table blueprint, Integer filtertype, EGroupID splitGroup ) RETURNS: Void =>Filters an EGroup by blueprint. 
EGroup_FilterUnderConstruction( EGroupID egroup, Integer filtertype ) RETURNS: Void =>Filters an EGroup by construction status. 
EGroup_ForEach( EGroup * egroup, LuaBinding::StackVarFunction f ) RETURNS: bool =>Call a lua function for each item in a group. Function will recieve (groupid, itemindex, itemid) and should return true to break or false to continue. 
EGroup_ForEachAllOrAny( EGroup * egroup, bool all, LuaBinding::StackVarFunction f ) RETURNS: bool =>Call a lua function for each item in a group. Function will receive (groupid, itemindex, itemid) and should return a bool. 
EGroup_ForEachAllOrAnyEx( EGroup * egroup, bool all, LuaBinding::StackVarFunction f, bool spawned, bool despawned ) RETURNS: bool =>Same as EGroup_ForEachAllOrAny except you have a choice to iterate over spawned entities, despawned entities, or both. 
EGroup_ForEachEx( EGroup * egroup, LuaBinding::StackVarFunction f, bool spawned, bool despawned ) RETURNS: bool =>Same as EGroup_ForEach except you have a choice to iterate over spawned entities, despawned entities, or both. 
EGroup_FromName( const char * name ) RETURNS: EGroup * =>Find an entity group with a given name. 
EGroup_GetAvgHealth( EGroupID egroup ) RETURNS: Real =>Returns the average health of all units in a entity group. 
EGroup_GetDeSpawnedEntityAt( EGroup * group, unsigned int index ) RETURNS: Entity * =>Returns the despawned entity at the given index. 
EGroup_GetInvulnerable( EGroupID egroup, Boolean all ) RETURNS: Boolean =>Check invulnerablity state for ALL or ANY entity in an entity group. 
EGroup_GetLastAttacker( EGroup EGroupVictim, SGroup SGroupAttacker ) RETURNS: Void =>Gets the last attacker(s) for all the entities in an EGroup Gets the last attacker for all the squads in an SGroup and stores that in SGroupAttacker. 
EGroup_GetName( EGroup * egroup ) RETURNS: const char * =>Returns the name of a given entity group. 
EGroup_GetOffsetPosition( EGroupID egroup, Integer offset, Real value ) RETURNS: Position =>Returns a position (a certain distance away) relative to an entity's current position/orientation. see ScarUtil.scar for explanation of 'offset' parameter. 
EGroup_GetPosition( EGroup * group ) RETURNS: ScarPosition =>Returns the center position of an entity group. 
EGroup_GetRandomSpawnedEntity( EGroup egroupid ) RETURNS: EntityID =>Get a random spawned entity from egroup. 
EGroup_GetSequence( String name ) RETURNS: Table =>Builds a table of EGroupIDs that are named in a sequence. i.e. a name of "eg_building" will find groups "eg_building1", "eg_building2" and so on, up until it looks for a group that isn't there. 
EGroup_GetSpawnedEntityAt( EGroup * group, unsigned int index ) RETURNS: Entity * =>Returns the spawned entity at the given index. 
EGroup_GetSpawnedEntityFilter( EGroup egroupid, function  condition ) RETURNS: EntityID =>Get the first spawned entity from egroup that meets the condition (a function that takes an entity) 
EGroup_GetSpread( EGroupID egroup ) RETURNS: Real =>Returns the distance from the centre of the group of the entity that furthest out. 
EGroup_GetSquadsHeld( EGroupID egroup, SGroupID sgroupRecipient ) RETURNS: Void =>Returns an sgroup containing all squads held by any entities in an egroup. 
EGroup_GetWBTable( String format ) RETURNS: LuaTable =>Returns a table of egroups from the world builder. 
EGroup_HasUpgrade( EGroupID egroup, UpgradeID upgrade, Boolean all ) RETURNS: Boolean =>Returns whether ANY or ALL entities in an EGroup have the specified upgrade. 
EGroup_Hide( EGroupID egroup, Bool hide ) RETURNS: Void =>Hide or show all entities in an EGroup. 
EGroup_InstantCaptureStrategicPoint( EGroupID egroup, PlayerID player ) RETURNS: Void =>Change the ownership of a Strategic Point. 
EGroup_InstantRevertOccupiedBuilding( EGroupID egroup ) RETURNS: Void =>Reverts an occupied building. 
EGroup_Intersection( EGroup * group, EGroup * grouptointersect ) RETURNS: void =>Performs a group intersection. 
EGroup_IsBurning( EGroupID egroup, Boolean ALL ) RETURNS: Boolean =>Checks if ANY or ALL entities in an egroup are on fire (ignition threshold exceeded) 
EGroup_IsCapturedByPlayer( EGroupID egroup, PlayerID playerId, Boolean all ) RETURNS: Boolean =>Returns true if all or any strategic points in a group have been captured. Use ANY or ALL. 
EGroup_IsCapturedByTeam( EGroupID egroup, TeamID teamId, Boolean all ) RETURNS: Boolean =>Returns true if all or any strategic points in a group have been captured. Use ANY or ALL. 
EGroup_IsDoingAttack( EGroupID egroup, Boolean all, Float time ) RETURNS: Boolean =>Returns true if ALL or ANY entities are attacking within the time. 
EGroup_IsEmpty( EGroupID egroup ) RETURNS: Boolean =>Returns true if a named entity group contains no spawned or despawned entities. 
EGroup_IsHoldingAny( EGroupID egroup ) RETURNS: Void =>Returns whether any entity in an EGroup has a hold on anything. 
EGroup_IsInCover( EGroupID egroup, Boolean all ) RETURNS: Boolean =>Returns true if ALL or ANY entities are in cover. 
EGroup_IsMoving( EGroupID egroupid, Boolean all ) RETURNS: Boolean =>Returns true if ANY or ALL entities in an EGroup are moving. 
EGroup_IsOnScreen( PlayerID player, EGroupID group, Bool all, Float percent ) RETURNS: Bool =>Returns true if ANY or ALL (use those keywords) of the enities in the group are present onscreen. You can pass in a percentage of the screen to check, so 0.8 would be a centered rectangle occupying 80% of the screen. 
EGroup_IsProducingSquads( EGroupID egroup, Boolean all ) RETURNS: Boolean =>Returns true if ALL or ANY entities in a group are currently producing squads. 
EGroup_IsSpawned( EGroupID egroup, Boolean ALL ) RETURNS: Boolean =>Checks if ANY or ALL entities in an group are currently spawned or not. 
EGroup_IsUnderAttack( EGroupID egroup, Boolean all, Float time ) RETURNS: Boolean =>Returns true if ALL or ANY entities are under attack within the time. 
EGroup_IsUnderAttackByPlayer( EGroupID group, PlayerID attackerplayer, Float duration ) RETURNS: Bool =>Check if the entities are attacked by the player. 
EGroup_IsUnderAttackFromDirection( EGroupID egroup, Boolean all, Integer/Table offset, Float time ) RETURNS: Boolean =>Returns true if ALL or ANY entities are under attack from a direction within the time. see ScarUtil.scar for types of directions. you can pass in a table of offsets. 
EGroup_IsUsingAbility( EGroupID egroup, Boolean ALL ) RETURNS: Boolean =>Checks if ANY or ALL squads within an EGroup are using an ability. 
EGroup_Kill( EGroupID egroup ) RETURNS: Void =>Kill all entities in an EGroup. 
EGroup_NotifyOnPlayerDemolition( EGroupID id, LuaFunction function ) RETURNS: Void =>Calls a function when any entity in an EGroup gets destroyed by the player clicking the "Detonate me" button. 
EGroup_Remove( EGroup * group, Entity * entity ) RETURNS: void =>Removes an entity from a group. 
EGroup_RemoveDemolitions( EGroupID egroup ) RETURNS: Void =>Removes all demolition charges on an egroup. 
EGroup_RemoveGroup( SGroupID group, SGroupID grouptoremove ) RETURNS: Void =>Remove from the first SGroup all squads contained in the second SGroup. SGroup2 remains untouched. 
EGroup_RemoveUpgrade( EGroupID egroup, UpgradeBlueprint/Table upgrade ) RETURNS: Void =>Removes upgrade(s) from an egroup. 
EGroup_ReSpawn( EGroupID egroup ) RETURNS: Void =>Respawn all despawned entities in a group. 
EGroup_SetAnimatorAction( EGroupID egroup, String actionName ) RETURNS: Void =>Trigger animation action for an EGroup. Please only use this for simple animations. 
EGroup_SetAnimatorEvent( EGroupID egroup, String eventName ) RETURNS: Void =>Set animation event for an EGroup. Please only use this for simple animations. 
EGroup_SetAnimatorState( EGroupID egroup, String stateMachineName, String stateName ) RETURNS: Void =>Set animation state of a state machine for an EGroup. Please only use this for simple animations. 
EGroup_SetAnimatorVariable( EGroupID egroup, String variableName, Real value ) RETURNS: Void =>Set animation variable value for an EGroup. Please only use this for simple animations. 
EGroup_SetAutoTargetting( EGroupID group, String hardpoint, Bool enable ) RETURNS: Void =>Sets whether a weapon to auto-target things or not. 
EGroup_SetAvgHealth( EGroupID egroup, Real healthPercent ) RETURNS: Real =>Sets the health of each unit in an entity group to a given percent [0.0, 1.0]. 
EGroup_SetCrushable( EGroupID egroup, Boolean crushable ) RETURNS: Void =>Overrides crushable behavior for an egroup. 
EGroup_SetDemolitions( PlayerID player, EGroupID egroupid, Integer numcharges ) RETURNS: Void =>Instantly wires a building for demolitions. 
EGroup_SetHealthMinCap( EGroupID egroup, float minhealth ) RETURNS: Void =>Set the minimum health for this entity. 
EGroup_SetInvulnerable( EGroupID egroup, Boolean enabled, Float reset_time ) RETURNS: Void =>Enable/Disable invulnerablity for an entire entity group. Use true and false for simple on/off, or use a number between 0.0 and 1.0 for more precise control on how much damage an entity can take before it takes no more. 
EGroup_SetPlayerOwner( EGroup egroup, PlayerID owner ) RETURNS: Void =>Changes the player owner for all spawned and despawned entities of an EGroup. 
EGroup_SetRallyPoint( EGroupID egroup, Position target ) RETURNS: Void =>Set the rally point for this entity. 
EGroup_SetRecrewable( EGroupID sgroup, Boolean recrewable ) RETURNS: Void =>Sets all entities in an egroup to be recrewable or not when abandoned. 
EGroup_SetSelectable( EGroupID egroup, Bool selectable ) RETURNS: Void =>Set player selectable state of entities in the egroup. 
EGroup_SetSharedProductionQueue( EGroupID egroup, Boolean enable ) RETURNS: Void =>Enables shared team production on a building (teammates can build using THEIR resources) 
EGroup_SetStrategicPointNeutral( EGroupID egroup ) RETURNS: Void =>Sets a strategic point to neutral (not owned by any team) 
EGroup_SetWorldOwned( EGroupID egroup ) RETURNS: Void =>Makes an egroup neutral. 
EGroup_Single( EGroupID egroup, entityID entity ) RETURNS: EGroupID =>Creates an entity group containing a single entity. 
Entity_ApplyCritical( Entity * pEntity, ScarCriticalPBG criticalPBG, float removeAtHealth ) RETURNS: void =>Trigger a critical hit on an entity. 
Entity_BuildingPanelInfo( Entity * pEntity, ScarPosition cam, ScarPosition terrain ) RETURNS: void =>Displays info about the panel that is intersected by the passed in ray. 
Entity_CalculatePassableSpawnPosition( ScarEntityPBG ebp, ScarPosition pos ) RETURNS: ScarPosition =>pass in a entity and position to resolve the position into a open space position, if the position is not free, position returned will try to be the closest position near the original position 
Entity_CanAttackNow( Entity * attacker, ScarPosition target ) RETURNS: bool =>Returns whether an entity can attack a target without moving or turning. 
Entity_CancelProductionQueueItem( Entity * entity, uint32_t index ) RETURNS: void =>Cancels an item in a production queue. Index 0 is the currently producing item. 
Entity_CanLoadSquad( Entity * entity, Squad * squad, bool bCheckSquadState, bool bOverload ) RETURNS: bool =>Check if the entity can load squad or not. 
Entity_CanSeeEntity( Entity * entity, Entity * target ) RETURNS: bool =>Returns true if the distance between a target entity and the source entity is less than it entity's sight distance. There is no LOS or FOW check. 
Entity_CanSeeSquad( Entity * entity, Squad * target ) RETURNS: bool =>Returns true if the distance between a target squad and the source entity is less than it entity's sight distance. There is no LOS or FOW check. 
Entity_ClearPostureSuggestion( Entity * entity ) RETURNS: void =>Clears any previous posture suggestions made to an entity. 
Entity_ClearTagDebug(  ) RETURNS: void =>Clears the tagged entity used for debugging. 
Entity_CompleteUpgrade( Entity * pEntity, ScarUpgradePBG upgradePBG ) RETURNS: void =>Instantly adds an upgrade to a given entity. 
Entity_Create( ScarEntityPBG ebp, Player * player, ScarPosition pos, ScarPosition toward ) RETURNS: Entity * =>Creates an entity at a given position and assigns it to a given player. 'blueprint' is a string value containing the name of the entity blueprint. This function does not spawn the entity so you will need to call Entity_Spawn to see this entity. 
Entity_CreateENV( ScarEntityPBG ebp, ScarPosition pos, ScarPosition toward ) RETURNS: Entity * =>Creates an entity at a given position and assigns it to a given player. 'blueprint' is a string value containing the name of the entity blueprint. This function spawns the entity so there is no need to call Entity_Spawn. 
Entity_DeSpawn( Entity * entity ) RETURNS: void =>DeSpawn the entity at its current position. 
Entity_Destroy( Entity * entity ) RETURNS: void =>Remove an entity from the world and destroy it. 
Entity_DisableBuildingDeath( Entity * pEntity, bool bDisableDeath ) RETURNS: bool =>Disables the death of the given entity building, only works for panel based destructible buldings. 
Entity_DoBuildingDamageRay( Entity * pEntity, ScarPosition cam, ScarPosition terrain, size_t dmgType, bool isDestroy, float radius ) RETURNS: void =>Damages this entity but only if its a destructible building. 
Entity_EnableAttention( Entity * entity, bool attentive ) RETURNS: void =>Sets whether an entity pays attention to its surroundings. 
Entity_EnableProductionQueue( Entity * entity, bool enable ) RETURNS: void =>Sets whether an entity can produce anything (including upgrades) 
Entity_EnableStrategicPoint( Entity * entity, bool enable ) RETURNS: void =>Sets whether an strategic point is active. 
Entity_ForceConstruct( Entity * e ) RETURNS: void =>Force constructs this entity but only if its a building. 
Entity_FromWorldID( uint32_t id ) RETURNS: Entity * =>Get an entity from a mission editor ID. 
Entity_GetActiveCommand( Entity * entity ) RETURNS: EntityStateID =>Returns the active entity command. 
Entity_GetBlueprint( Entity * entity ) RETURNS: ScarEntityPBG =>Returns the entity's blueprint. 
Entity_GetBuildingProgress( Entity * pEntity ) RETURNS: float =>Returns the construction progress (with range [0.0, 1.0] for a given entity. Returns 0.0 if the entity is not a building. 
Entity_GetCoverValue( Entity * entity ) RETURNS: float =>Get cover safety value from the where the entity is standing. The safety value is number from -.5 to .5. 
Entity_GetGameID( Entity * entity ) RETURNS: uint32_t =>Returns the entities unique id in the world. 
Entity_GetHeading( Entity * entity ) RETURNS: ScarPosition =>Returns the heading of the entity. The heading is currently a lua table with three entries (x, y, z) 
Entity_GetHealth( Entity * entity ) RETURNS: float =>Returns the health of an entity. 
Entity_GetHealthMax( Entity * entity ) RETURNS: float =>Returns the max health of an entity. 
Entity_GetHealthPercentage( Entity * entity ) RETURNS: float =>Returns the percentage health, taking into account destructible buildings. 
Entity_GetInvulnerable( SquadID squad ) RETURNS: Bool =>Check if the entity is invulnerable or not. 
Entity_GetInvulnerableMinCap( Entity * entity ) RETURNS: float =>Returns the invulnerable point in terms of percentage. 
Entity_GetInvulnerableToCritical( Entity * entity ) RETURNS: bool =>get if an entity is invulnerable to critical effects 
Entity_GetLastAttacker( Entity * entity, SGroup * group ) RETURNS: void =>Find the last squad attacker on this entity. If found, the squad is added to the sgroup. 
Entity_GetLastAttackers( Entity * entity, SGroup * group, float timeSeconds ) RETURNS: void =>Find the squad attackers on this entity from the last seconds specified. If found, the squads are added to the sgroup. Building attackers are ignored. 
Entity_GetMaxCaptureCrewSize( Entity * entity ) RETURNS: int =>Gets the maximum capture crew size from a recrewable entity. 
Entity_GetOffsetPosition( EntityID entity, Integer offset, Real distance ) RETURNS: Position =>Returns a position relative to an entity's current position and orientation. see ScarUtil.scar for explanation of 'offset' parameter. 
Entity_GetPlayerOwner( Entity * entity ) RETURNS: Player * =>Returns the Player owner of the given entity. Entity MUST NOT be owned by the world. 
Entity_GetPosition( Entity * entity ) RETURNS: ScarPosition =>Returns the position of the entity. The position is currently a lua table with three entries (x, y, z) 
Entity_GetProductionQueueItem( Entity * entity, uint32_t index ) RETURNS: const PropertyBagGroup * =>Returns the blueprint for a production queue item with index. 
Entity_GetProductionQueueItemType( Entity * entity, uint32_t index ) RETURNS: ProductionItemType =>Returns the production type (PITEM_Upgrade, PITEM_Spawn, PITEM_SquadUpgrade, PITEM_SquadReinforce, PITEM_PlayerUpgrade) for a production queue item with index. 
Entity_GetProductionQueueSize( Entity * entity ) RETURNS: uint32_t =>Returns the number of items in the entities production queue. 
Entity_GetResourceType( Entity * entity ) RETURNS: ResourceAmount::ResourceType =>Returns the resource type of this point. 
Entity_GetSightInnerHeight( Entity * entity ) RETURNS: float =>Returns the inner sight radius for this entity. 
Entity_GetSightInnerRadius( Entity * entity ) RETURNS: float =>Returns the inner sight radius for this entity. 
Entity_GetSightOuterHeight( Entity * entity ) RETURNS: float =>Returns the outer sight radius for this entity. 
Entity_GetSightOuterRadius( Entity * entity ) RETURNS: float =>Returns the outer sight radius for this entity. 
Entity_GetSquad( Entity * pEntity ) RETURNS: Squad * =>Returns the Squad for the passed Entity. (May be nullptr) 
Entity_GetSquadsHeld( Entity * pEntity, SGroup * sgroup ) RETURNS: bool =>Adds squads held by an entity to an SGroup. 
Entity_GetTotalPanelCount( Entity * pEntity ) RETURNS: size_t =>Gets the total number of panels in a building (returns 0 for anything but panel based destructible buldings) 
Entity_GetUndestroyedPanelCount( Entity * pEntity ) RETURNS: size_t =>Gets the current number of undestroyed panels in a building (returns 0 for anything but panel based destructible buldings) 
Entity_GetWeaponBlueprint( Entity * entity, int hardPointIndex ) RETURNS: ScarWeaponPBG =>Returns a weapon hardpoint ( 0 indexed ) 
Entity_GetWeaponHardpointCount( Entity * entity ) RETURNS: size_t =>Returns how many hardpoints an entity has. 
Entity_HasAnyCritical( Entity * pEntity ) RETURNS: bool =>Return true if the entity has any critical applied to it. 
Entity_HasCritical( Entity * pEntity, ScarCriticalPBG criticalPBG ) RETURNS: bool =>Return true if the entity has the given criticalID applied to it. 
Entity_HasProductionQueue( Entity * entity ) RETURNS: bool =>Returns true if an entity has a production queue. 
Entity_HasUpgrade( Entity * pEntity, ScarUpgradePBG upgradePBG ) RETURNS: bool =>Return true if the entity has purchased the specified upgrade. 
Entity_InstantCaptureStrategicPoint( Entity * entity, Player * player ) RETURNS: void =>Strategic point will be captured instantly by the team of the supplied player. 
Entity_InstantRevertOccupiedBuilding( Entity * entity ) RETURNS: void =>Reverts an occupied building. 
Entity_IsAlive( Entity * pEntity ) RETURNS: uint32_t =>Returns true if entity is still alive. 
Entity_IsAttacking( Entity * entity, float time ) RETURNS: bool =>Returns true if the entity is attacking within the time. 
Entity_IsBuilding( Entity * e ) RETURNS: bool =>Returns true if the given entity is a building. 
Entity_IsBurning( Entity * e ) RETURNS: bool =>Returns true if the given entity is burning (buildings on fire or non-buildings with burn_exts) 
Entity_IsCamouflaged( Entity * entity ) RETURNS: bool =>Returns whether the entity is camouflaged. 
Entity_IsCapturableBuilding( Entity * entity ) RETURNS: bool =>Returns true if the entity is a capturable building. 
Entity_IsCasualty( Entity * entity ) RETURNS: bool =>Returns true if entity is a casualty else false. 
Entity_IsCuttable( Entity * entity ) RETURNS: bool =>Returns whether this entity is cuttable. 
Entity_IsDemolitionReady( Entity * entity ) RETURNS: bool =>Returns whether this entity's demolition charges are ready to be detonated. 
Entity_IsEBPBuilding( ScarEntityPBG ebp ) RETURNS: uint32_t =>Returns true if the given blueprint is a building. 
Entity_IsEBPObjCover( ScarEntityPBG ebp ) RETURNS: bool =>Returns true if the given blueprint is objcover. 
Entity_IsEBPOfType( ScarEntityPBG ebp, const char * type ) RETURNS: bool =>Returns true if the given blueprint is of the given type. Types are defined in type_ext/unit_type_list. 
Entity_IsHardpointActive( Entity * entity, int hardPointIndex ) RETURNS: bool =>Returns whether a hardpoint is active ( 0 indexed ) 
Entity_IsHoldingAny( Entity * entity ) RETURNS: bool =>Check if the entity has a hold on anything. 
Entity_IsInCover( EntityID entityId ) RETURNS: Boolean =>Returns true if entity is in cover. 
Entity_IsMoving( Entity * pEntity ) RETURNS: bool =>Returns whether an entity is moving. 
Entity_IsOfType( Entity * entity, const char * type ) RETURNS: bool =>Determines if this entity is of the given type. Types are defined in type_ext/unit_type_list. 
Entity_IsPartOfSquad( Entity * pEntity ) RETURNS: bool =>Returns true if the entity is part of a squad. 
Entity_IsPlane( Entity * pEntity ) RETURNS: bool =>Returns whether an entity is a plane (has a flight extension) 
Entity_IsSlotItem( Entity * entity ) RETURNS: bool =>Return true if the entity is a slot item. 
Entity_IsSoldier( Entity * pEntity ) RETURNS: bool =>Returns whether an entity is a soldier. 
Entity_IsSpawned( Entity * entity ) RETURNS: bool =>if entity is spawned return true 
Entity_IsStartingPosition( Entity * entity ) RETURNS: bool =>Returns true if the entity is a starting position. 
Entity_IsStrategicPoint( Entity * entity ) RETURNS: bool =>Returns true if the entity is a strategic point. 
Entity_IsStrategicPointCapturedBy( Entity * entity, Player * player ) RETURNS: bool =>Returns true if strategic point is captured by the team of the player provided. 
Entity_IsSyncWeapon( Entity * entity ) RETURNS: bool =>Return true if the entity is a team weapon. 
Entity_IsUnderAttack( Entity * entity, float time ) RETURNS: bool =>Returns true if the entity is under attack. 
Entity_IsUnderAttackByPlayer( Entity * entity, Player * pAttackerOwner, float time ) RETURNS: bool =>Returns true if the entity is under attack by a certain player. 
Entity_IsUnderAttackFromDirection( Entity * entity, int offset, float timeSeconds ) RETURNS: bool =>Returns true if the entity was under attack from a certain direction (8 offset types, see ScarUtil.scar) 
Entity_IsValid( uint32_t id ) RETURNS: bool =>Check if an entity with the given ID can be found in the world. 
Entity_IsVaultable( Entity * pEntity ) RETURNS: bool =>Returns whether an entity can be vaulted. 
Entity_IsVehicle( Entity * pEntity ) RETURNS: bool =>Returns whether an entity is a vehicle. 
Entity_IsVictoryPoint( Entity * pEntity ) RETURNS: bool =>Returns true if entityID is a victory point. 
Entity_Kill( Entity * entity ) RETURNS: void =>Kill the entity. Sets health to 0, and triggers death effects. 
Entity_NotifyOnPlayerDemolition( Entity entity, LuaFunction function ) RETURNS: Void =>Calls a function when an entity gets destroyed by the player clicking the "Detonate me" button next to an entity. 
Entity_Population( Entity * entity, CapType type ) RETURNS: float =>get entity pop cost, use CT_Personnel, CT_Vehicle, CT_Medic for captype 
Entity_RemoveBoobyTraps( Entity * pEntityTarget ) RETURNS: void =>Removes all booby-traps on this entity. 
Entity_RemoveCritical( Entity * pEntity, ScarCriticalPBG criticalPBG ) RETURNS: void =>Remove a critical from a given entity. 
Entity_RemoveDemolitions( Entity * entity ) RETURNS: void =>Removes all demolition charges on an entity. 
Entity_RemoveUpgrade( Entity * entity, ScarUpgradePBG upgrade ) RETURNS: void =>Removes an upgrade from an entity. 
Entity_SetAnimatorAction( Entity * pEntity, const char * actionName ) RETURNS: void =>Trigger animation action for an entity. Please only use this for simple animations. 
Entity_SetAnimatorActionParameter( Entity * pEntity, const char * actionParameterName, const char * actionParameterValue ) RETURNS: void =>Set animation action parameter for an entity. Please only use this for simple animations. 
Entity_SetAnimatorEvent( Entity * pEntity, const char * eventName ) RETURNS: void =>Set animation event for an entity. Please only use this for simple animations. 
Entity_SetAnimatorState( Entity * pEntity, const char * stateMachineName, const char * stateName ) RETURNS: void =>Set animation state of a state machine for an entity. Please only use this for simple animations. 
Entity_SetAnimatorVariable( Entity * pEntity, const char * variableName, float value ) RETURNS: void =>Set animation variable value for an entity. Please only use this for simple animations. 
Entity_SetBuildingVisualFireState( Entity * pEntity, BuildingDestructionExt::BuildingFireState newFireState ) RETURNS: void =>Set the visual fire state of a building (doesn't actually set the building on fire) 
Entity_SetCrushable( Entity * entity, bool crushable ) RETURNS: void =>Overrides crushable behavior for an entity. 
Entity_SetCrushMode( Entity * entity, CrushExtInfo::CrushMode mode ) RETURNS: void =>Changes the crush mode of a given entity. Entity must have a crush extension. 
Entity_SetDemolitions( Player * player, Entity * entity, int numcharges ) RETURNS: bool =>Fully wires this entity for demolitions, if it's set up to be demolishable. 'player' is the one that owns the demolitions and can detonate them. 
Entity_SetEnableCasualty( bool enable, Entity * pEntity ) RETURNS: void =>enable or disable the casualtext 
Entity_SetHeading( Entity * entity, ScarPosition pos, bool bInterpolate ) RETURNS: void =>Sets the heading of the entity. The position is currently a lua table with three entries (x, y, z) 
Entity_SetHealth( Entity * entity, float healthPercent ) RETURNS: void =>Set the health of an entity. healthPercent must be in the range [0.0, 1.0]. 
Entity_SetInvulnerable( EntityID entity, Bool enable, Float reset_time ) RETURNS: Void =>Set invulnerability on the entity. Reset time is in seconds. If it it set, the invulnerability will expire after this time. 
Entity_SetInvulnerableMinCap( Entity * entity, float minHealthPercentage, float resetTime ) RETURNS: void =>Make an entity invulnerable to physical damage when health is below the minimum health percentage. 
Entity_SetInvulnerableToCritical( Entity * entity, bool invulnerable ) RETURNS: void =>set an entity invulnerable to critical effects. Invulnerable to critical also means that kills a entity will not have effect 
Entity_SetOnFire( Entity * pEntity ) RETURNS: void =>Sets an object on fire (also works on buildings) 
Entity_SetPlayerOwner( Entity * entity, Player * owner ) RETURNS: void =>Changes the owner of the given squad. 
Entity_SetPosition( Entity * entity, ScarPosition pos ) RETURNS: void =>Sets the position of the entity. The position is currently a lua table with three entries (x, y, z) 
Entity_SetProjectileCanExplode( Entity * projectile, bool canExplode ) RETURNS: void =>Sets whether or not a projectile can explode. 
Entity_SetRecrewable( Entity * entity, bool capturable ) RETURNS: void =>Sets an entity to be recrewable or not when it becomes abandoned. 
Entity_SetSharedProductionQueue( Entity * entity, bool shared ) RETURNS: void =>Enables shared team production on a building (teammates can build using THEIR resources) 
Entity_SetStrategicPointNeutral( Entity * entity ) RETURNS: void =>Sets a strategic point to neutral (not owned by any team) 
Entity_SetWorldOwned( Entity * entity ) RETURNS: void =>Makes an entity neutral. 
Entity_SimHide( Entity * entity, bool hide ) RETURNS: void =>Shows/hides the entity in the simulation. 
Entity_Spawn( Entity * entity ) RETURNS: void =>Spawn the entity at its current position. 
Entity_StopAbility( Entity * entity, ScarAbilityPBG ability, bool bEarlyExit ) RETURNS: void =>Abruptly stops an active ability. 
Entity_SuggestPosture( Entity * entity, unsigned posture, float duration ) RETURNS: void =>Suggests a posture to an entity, lasting the passed duration. 
Entity_SupportsDemolition( Entity * entity ) RETURNS: bool =>Returns whether this entity is set up to have demolitions placed on it. 
Entity_TagDebug( Entity * entity ) RETURNS: void =>Tags the entity to be used for debugging. 
Entity_VisHide( Entity * pEntity, bool bHide ) RETURNS: void =>Hides or shows an entity visually. 
EntityQuery_CanCauseSuppression( AIPlayer * aiPlayer, Entity * entity ) RETURNS: bool =>Checks if this entity can cause suppression. 
EntityQuery_CanLoadSquadAndAttackCurrentTarget( Entity * entity, Squad * squad, bool bCheckSquadState, bool bOverload ) RETURNS: bool =>Check if the entity can load squad and shoot its target after loading (This function should only be called by AI) 
EntityQuery_FindClosestOpenPositionForStructure( AIPlayer * aiPlayer, const PropertyBagGroup * pEntityPBG, ScarPosition posIn ) RETURNS: ScarPosition =>Find the closest open position from a given position for a given Entity blueprint. 
Enum_ToNumber( LuaBinding::StackVar var ) RETURNS: int =>Converts any enum value to a number. 
Enum_ToString( LuaBinding::StackVar var ) RETURNS: std::string =>Converts any enum value to a string. 
Event_CreateAND( Function callback, Table data, Table events, Float delay ) RETURNS: EventID =>Creates a Callback Event that triggers when ALL of the specified events are triggered. 
Event_CreateOR( Function callback, Table data, Table events, Float delay ) RETURNS: EventID =>Creates a Callback Event that triggers when ANY of the specified events are triggered. 
Event_Delay( float seconds ) RETURNS: void =>Pauses for a given amount of time. This function MUST be called from a CTRL object in NISlet events only! 
Event_ElementOnScreen( Function callback, Table data, PlayerID player, Marker/Pos/SGroup/EGroup element, ANY/ALL all, Float percent, bool canSee, Float delay ) RETURNS: EventID =>Callback given callback function with data, when the given squad/entity/position is on screen. 
Event_EncounterIsDead( Function callback, Table data, Table encID, Float delay ) RETURNS: EventID =>Trigger a Callback when an encounter is killed. 
Event_Exists( EventID eventID ) RETURNS: BOOL =>checks to see if the given event currently exists 
Event_GroupBurning( Function callback, Table data, EGroup/Entity group/ entityID, Float delay ) RETURNS: EventID =>Callback given callback function with data, when the egroup is burning. 
Event_GroupCount( ScarFN callback, Table data, EGroup/SGroup group, Int count, bool spawned, Float delay ) RETURNS: EventID =>Callback when the number of squads/entities in a group is <= count. 
Event_GroupHasCritical( Function callback, Table data, SGroup group, Float delay, BP Critical, Bool ANY/ ALL, Float delay ) RETURNS: EventID =>Callback given callback function with data, when entire group has a specified critical. 
Event_GroupIsDead( Function callback, Table data, EGroup/SGroup group, Float delay, Boolean retreating ) RETURNS: EventID =>Callback given callback function with data, when group is dead (empty). 
Event_GroupIsNotPinned( Function callback, Table data, SGroup group, bool ANY/ ALL, Float delay ) RETURNS: EventID =>Callback given callback function with data, when group is not pinned. 
Event_GroupIsNotSuppressed( Function callback, Table data, SGroup group, bool ANY/ ALL, Float delay ) RETURNS: EventID =>Callback given callback function with data, when group is not suppressed. 
Event_GroupIsPinned( Function callback, Table data, SGroup group, bool ANY/ ALL, Float delay ) RETURNS: EventID =>Callback given callback function with data, when group is pinned. 
Event_GroupIsSuppressed( Function callback, Table data, SGroup group, bool ANY/ ALL, Float delay ) RETURNS: EventID =>Callback given callback function with data, when group is suppressed. 
Event_GroupLeftAlive( Function callback, Table data, EGroup/SGroup group, Int amount, Float delay ) RETURNS: EventID =>Callback given callback function with data, when the amount of entities left in a group drops below amount. 
Event_IsAnyRunning( Integer priority_threshold ) RETURNS: Boolean =>Returns true if any event is currently running [at or below (more important than) the priority threshold. If not specified, ignores threshold.]. 
Event_IsDoingAttack( Function callback, Table data, EGroup/SGroup group, ANY/ALL all, Float attackTime, Float delay ) RETURNS: EventID =>Callback given callback function with data, when group is doing an attack in the last attackTime seconds. 
Event_IsEngaged( Function callback, Table data, EGroup/SGroup group, ANY/ALL all, Float attackTime, Float delay ) RETURNS: EventID =>Callback given callback function with data, when group is doing an attack or is under attack in the last attackTime seconds. 
Event_IsHoldingAny( Function callback, Table data, EGroup/SGroup/Entity/Squad target, Boolean empty, Float delay ) RETURNS: EventID =>Callback given callback function with data, when an element is holding anything or nothing. 
Event_IsHoldingBP( Function callback, Table data, EGroup/SGroup/Entity/Squad target, SquadBP/Table blueprint, Float delay ) RETURNS: EventID =>Callback given callback function with data, when an element is holding a specific BP. 
Event_IsInHold( Function callback, Table data, SGroup/Squad target, Boolean inHold, ANY/ ALL, Float delay ) RETURNS: EventID =>Callback given callback function with data, when a target element is in a hold or not. 
Event_IsQueued( LuaConfig::RefFunction f ) RETURNS: bool =>Returns true if a given event is running. 
Event_IsRunning( LuaConfig::RefFunction f ) RETURNS: bool =>Returns true if a given event is running. 
Event_IsSelected( Function callback, Table data, SGroup/Squad/EGroup/entity target, ANY/ ALL, Float delay ) RETURNS: EventID =>Callback when a target element is selected. 
Event_IsUnderAttack( Function callback, Table data, EGroup/SGroup group, bool ANY/ ALL, Float attackTime, PlayerID player, Float delay ) RETURNS: EventID =>Callback given callback function with data, when group is under attack in the last attackTime seconds. 
Event_MembersCount( Function callback, Table data, SGroupID sgroup, Int amount, Float delay ) RETURNS: EventID =>Callback when an SGroup's member count <= amount. 
Event_NarrativeEventsNotRunning( Function callback, Table data, Float delay ) RETURNS: EventID =>Callback given callback function with data, when no narrative event are running. 
Event_NarrativeEventsRunning( Function callback, Table data, Float delay ) RETURNS: EventID =>Callback given callback function with data, when narrative events are running. 
Event_ObjectiveStarted( Function callback, Table data, ObjectiveID Objective, Float delay ) RETURNS: EventID =>Callback given callback function with data, when the given objective has started. 
Event_OnHealth( Function callback, Table data, EGroup/SGroup/Entity/Squad target, Float threshold, Boolean higher, Float delay ) RETURNS: EventID =>Callback given callback function with data, when an element's health falls below (or above if higher is true) given threshold. 
Event_PlayerBuildingCount( Function callback, Table data, PlayerID player, Int amountOfBuilding, Float delay ) RETURNS: EventID =>Callback given function with data, when player has greater than or equal to amountOfBuildings. 
Event_PlayerCanNotSeeElement( Function callback, Table data, PlayerID player, SquadID/SGroupID/EntityID/EGroupID/Marker/Position Table element, ANY/ALL all, Float delay ) RETURNS: EventID =>Callback given callback function with data, when the given player can not see the element. 
Event_PlayerCanSeeElement( Function callback, Table data, PlayerID/TeamID player/ team, SquadID/SGroupID/EntityID/EGroupID/Marker/Position Table element, ANY/ALL all, Float delay ) RETURNS: EventID =>Callback given callback function with data, when the given player can see the element. 
Event_PlayerDoesntOwnTerritory( Function callback, Table data, PlayerID player, Int/Table/EGroup/Entity sectorID/group/ entity, Float delay ) RETURNS: EventID =>Callback given callback function with data, when player owns none of the given territories. 
Event_PlayerOwnsElement( Function callback, Table data, PlayerID player, Entity/EGroup/Squad/SGroup element, Float delay, Boolean all ) RETURNS: EventID =>Callback given function with data, when player owns the given element. 
Event_PlayerOwnsTerritory( Function callback, Table data, PlayerID player, SectorID/EGroup/Entity/Table territory, ANY/ALL all, Float delay ) RETURNS: EventID =>Callback given callback function with data, when player owns all given territories. 
Event_PlayerResourceLevel( Function callback, Table data, PlayerID player, ResourceType resourceType, Int amount, Float delay ) RETURNS: EventID =>Callback given callback function with data, when player has more than amount of resourceType. 
Event_PlayerSquadCount( Function callback, Table data, PlayerID player, Int amount, Float delay ) RETURNS: EventID =>Callback when a player's squad count <= amount. 
Event_Proximity( Function callback, Table data, PlayerID/Squad/Table/TeamID target, Marker/Pos/SectorID/Table/SGroup/EGroup location, REAL range, ANY/ALL all, Float delay ) RETURNS: EventID =>Callback given callback function with data when target enters location. 
Event_Remove( EventID eventID ) RETURNS: Void =>Remove the given callback. 
Event_RemoveAll( Bool immediate ) RETURNS: Void =>Remove all existing callback events. 
Event_Skip(  ) RETURNS: void =>Completes execution of the event immediately (all calls to Wait() are ignored) 
Event_Start( LuaConfig::RefFunction f, unsigned int priority ) RETURNS: void =>Starts event. Event will not start until all rules are evaluated for this frame! 
Event_StartEx( LuaConfig::RefFunction f, unsigned int priority, LuaConfig::RefFunction onComplete ) RETURNS: void =>Starts an event the same way as Event_Start, but calls a user defined function when the event is over. 
Event_TeamBuildingCount( Function callback, Table data, TeamID team, Int amountOfBuilding, Float delay ) RETURNS: EventID =>Callback given function with data, when player has greater than or equal to amountOfBuildings. 
Event_TeamCanNotSeeElement( Function callback, Table data, TeamID team, SquadID/SGroupID/EntityID/EGroupID/Marker/Position Table element, ANY/ALL all, Float delay ) RETURNS: EventID =>Callback given callback function with data, when the given team can not see the element. 
Event_TeamCanSeeElement( Function callback, Table data, TeamID team, SquadID/SGroupID/EntityID/EGroupID/Marker/Position Table element, ANY/ALL all, Float delay ) RETURNS: EventID =>Callback given callback function with data, when the given team can see the element. 
Event_TeamDoesntOwnTerritory( Function callback, Table data, TeamID team, Int/Table/EGroup/Entity sectorID/group/ entity, Float delay ) RETURNS: EventID =>Callback given callback function with data, when a team owns none of the given territories. 
Event_TeamOwnsElement( Function callback, Table data, TeamID team, Entity/EGroup/Squad/SGroup element, Float delay ) RETURNS: EventID =>Callback given function with data, when a team owns the given element. 
Event_TeamOwnsTerritory( Function callback, Table data, TeamID team, Int/Table/EGroup/Entity sectorID/group/ entity, ANY/ALL all, Float delay ) RETURNS: EventID =>Callback given callback function with data, when a team owns all given territories. 
Event_TeamResourceLevel( Function callback, Table data, TeamID team, ResourceType resourceType, Int amount, Float delay ) RETURNS: EventID =>Callback given callback function with data, when a team has a combined amount more than amount of resourceType. 
Event_TeamSquadCount( Function callback, Table data, TeamID team, Int amount, Float delay ) RETURNS: EventID =>Callback when a Team's squad count <= amount. 
Event_TerritoryInSupply( Function callback, Table data, PlayerID player, ScarPos territory, Boolean inSupply, Float delay ) RETURNS: EventID =>Callback when a territory is/is not in supply. 
Event_Timer( Function callback, Table data, INT/Table delay ) RETURNS: EventID =>Callback given callback function with data, after a specified delay. 
Event_ToggleDebug( UnknownType  ) RETURNS: Void =>Toggles the ScarEvent debugger ON and OFF. 
Event_View( INT eventID ) RETURNS: Void =>Calls the view_manager on a ScarEvent with a specific ID. 
EventCue_Create( CueStyleID style, LocString title, LocString description, Marker/Pos/EGroup/SGroup cameratarget, LocString hintpointtext, LuaFunction function, Float lifetime, Boolean dismissOnClick ) RETURNS: event =>Creates an Event Cue message which automatically sends the camera to a specified point when clicked on. 
EventHandler_AddEncounterUnits( Table data ) RETURNS: Void =>Callback helper function for adding unitse an Encounter. Name of parameters: 'units'. 
EventHandler_AssignEncounterGoal( Table data ) RETURNS: Void =>Callback helper function for assigning a goal to an Encounter. Name of parameters: 'goalData', 'encounter'. 
EventHandler_ObjectiveComplete( Table data ) RETURNS: Void =>Callback helper function for completing an objective. Received parameters: Table objective, Bool showTitle, Bool skipIntel. 
EventHandler_ObjectiveStart( Table data ) RETURNS: Void =>Callback helper function for starting an objective, name of objective parameter is objective, additional parameters: Bool showTitle, Bool skipIntel. 
EventHandler_RemoveHint( Table data ) RETURNS: Void =>Callback helper function for removing in-game hints. Name of hintpointID parameter is 'hint'. Can receive a table of ID's. 
EventHandler_RemoveMinimapBlip( Table data ) RETURNS: Void =>Callback helper function for removing in minimap blips, name of blipID parameter is blip. 
EventHandler_RemoveObjectiveUI( Table data ) RETURNS: Void =>Callback helper function that removes objective UI elements, name of parameters: objective, element. 
EventHandler_Retreat( Table data ) RETURNS: Void =>Callback helper function that causes the input group to retreat, name of parameters: group, location, deleteAtMarker, queued. 
EventHandler_StaggeredRetreat( Table data ) RETURNS: Void =>Callback helper function that causes the input group to retreat, name of parameters: group, location, maxTries. 
EventHandler_StartIntel( Table data ) RETURNS: Void =>Callback helper function for Intel events, name of intel parameter is intel. 
EventHandler_StartNislet( Table data ) RETURNS: Void =>Callback helper function for Intel Nislet events, name of intel parameter is intel. 
EventHandler_StopFlashing( Table data ) RETURNS: Void =>Callback helper function for removing UI flashing. Name of ID parameter is flashID. 
EventHandler_TriggerEncounterGoal( Table data ) RETURNS: Void =>Callback helper function for triggering an Encounter goal. Name of parameters: 'encounter'. 
FOW_Enable( Boolean enable ) RETURNS: Void =>Enables or disables the FOW, including out of bound areas and all entities on the map. 
FOW_PlayerExploreAll( ModPlayer * player ) RETURNS: void =>Explores entire map for one player. 
FOW_PlayerRevealAll( ModPlayer * player ) RETURNS: void =>Reveal FOW for specified player. 
FOW_PlayerRevealArea( ModPlayer * player, ScarPosition pos, float radius, float durationSecs ) RETURNS: void =>Reveals a circular area for the given player over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 
FOW_PlayerUnExploreAll( ModPlayer * player ) RETURNS: void =>Unexplores entire map for one player. 
FOW_PlayerUnRevealAll( ModPlayer * player ) RETURNS: void =>Use to undo a FOW_RevealAll for specified player. 
FOW_PlayerUnRevealArea( ModPlayer * player, ScarPosition pos, float radius ) RETURNS: void =>UnReveals a circular area for a given player. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 
FOW_RevealAll(  ) RETURNS: void =>Reveal FOW for all players. 
FOW_RevealArea( ScarPosition pos, float radius, float durationSecs ) RETURNS: void =>Reveals a circular area for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 
FOW_RevealEGroup( EGroup * group, float durationSecs ) RETURNS: void =>Reveals an entity groups line of sight(LOS) for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 
FOW_RevealEGroupOnly( EGroup * group, float durationSecs ) RETURNS: void =>Reveals an entity groups in FOW for all alive players over a given duration. 
FOW_RevealEntity( Entity * entity, float durationSecs ) RETURNS: void =>Reveals an entities line of sight (LOS) for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 
FOW_RevealMarker( MarkerID marker, Real duration ) RETURNS: Void =>Reveals an area the size of a given markers proximity at that markers position for a given amount of time. Pass in a duration of 1 for indefinite duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 
FOW_RevealSGroup( SGroup * group, float durationSecs ) RETURNS: void =>Reveals a squad groups line of sight(LOS) for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 
FOW_RevealSGroupOnly( SGroup * group, float durationSecs ) RETURNS: void =>Reveals a squad groups in fow for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 
FOW_RevealSquad( Squad * squad, float durationSecs ) RETURNS: void =>Reveals a squads line if sight(LOS) for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 
FOW_RevealTerritory( ModPlayer * player, int sectorID, float durationSecs, bool mustOwn ) RETURNS: void =>Reveals a territory to a player. 
FOW_UnRevealAll(  ) RETURNS: void =>Use to undo a FOW_RevealAll. 
FOW_UnRevealArea( ScarPosition pos, float radius ) RETURNS: void =>UnReveals a circular area for all alive players. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 
FOW_UnRevealMarker( MarkerID marker ) RETURNS: Void =>Unreveals an area the size of a given markers proximity at that markers position. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 
FOW_UnRevealTerritory( ModPlayer * player, int sectorID ) RETURNS: void =>Unreveals a territory sector. 
Game_DefaultGameRestore( Void  ) RETURNS: Void =>Restores various aspects of the single player game after loading a mission from a save game. 
Game_EndSP( Boolean win, Boolean nis, Boolean sandmap ) RETURNS: Void =>Ends the single player game (win/lose). 
Game_FadeToBlack( Bool direction, Real length ) RETURNS: Void =>Fades the screen to black - FADE_OUT to fade to black, FADE_IN to fade back in. 
Game_GetGameRestoreCallbackExists( Function callback ) RETURNS: Void =>Checks whether a callback. 
Game_RemoveGameRestoreCallback( Function callback ) RETURNS: Void =>Removes a callback from being called on game restore. 
Game_SetGameRestoreCallback( Function callback, parmeter1 , parameter2 , ...  ) RETURNS: Void =>Adds a function and set of arguments to be automatically called during restore from a saved game. Maxiumum of 9 parameters. Callback will be called like this: Callback(arg[1], arg[2], ...) 
Game_SubTextFade( LocString location, LocString time, LocString detail, Real in, Real lifetime, Real out ) RETURNS: Void =>Fade in and out two or three lines of subtext. 
HintMouseover_Add( LocString hintText, Marker/Position/Egroup/Sgroup hintTarget, Real targetRadius, Boolean looping ) RETURNS: Void =>Adds a Hint Point that will only appear on Mouseover of the target. 
HintMouseover_Remove( LocString hintText, Marker/Egroup/Sgroup hintTarget ) RETURNS: Void =>Removes a Mouseover Hint Point from the managing function. 
HintPoint_Add( StackVar where, Boolean bVisible, LocString hintText, number height, HintPointActionType actionType, String iconName ) RETURNS: HintPointID =>Creates a hintpoint attached to a Marker, EGroup, SGroup or position. 
HintPoint_Remove( Integer HintPointID ) RETURNS: Void =>Removes a hintpoint. 
HintPoint_SetDisplayOffset( Integer hintpointID, Real x, Real y, Real z ) RETURNS: Void =>Sets a hintpoint's display offset, which is 3D for world hintpoints and 2D for taskbar binding hintpoints (ignore z) 
HintPoint_SetVisible( Integer HintPointID, Boolean bVisible ) RETURNS: Void =>Sets a hintpoint's visibility. Currently, FOW is not accounted for. 
Import_Once( String Path ) RETURNS: nil =>Loads a scar file if it hasn't been loaded yet. 
Loc_FormatText( Integer FormatID, argc parameters ) RETURNS: LocString =>Returns a formatted localized string. 
MapIcon_CreateArrow( Marker/Pos position_from, Marker/Pos position_to, Int red, Int green, Int blue, Int alpha ) RETURNS: Void =>Creates an arrow on the metamap between the two locations provided. 
Marker_CleanUpTheDead( PlayerID player, MarkerID marker ) RETURNS: Void =>Kill off a specific player's dead bodies (enter ALL to clean them all up) in a marker radius. 
Marker_DoesNumberAttributeExist( ScarMarker marker, const char * name ) RETURNS: bool =>Returns true if a generic number attribute exists for the marker type. 
Marker_DoesStringAttributeExist( ScarMarker marker, const char * name ) RETURNS: bool =>Returns true if a generic string attribute exists for the marker type. 
Marker_Exists( const char * name, const char * type ) RETURNS: bool =>Returns true if marker exists. If you don't care about the type, pass in an empty string ( "" ) 
Marker_FromName( const char * name, const char * type ) RETURNS: ScarMarker =>Returns a ScarMarker from the Mission Editor. If you don't care about the type, pass in an empty string ( "" ) 
Marker_GetDirection( ScarMarker marker ) RETURNS: ScarPosition =>Returns a vector for the marker direction. 
Marker_GetName( ScarMarker marker ) RETURNS: const char * =>Returns the name of a given marker. This value gets set in the Mission Editor. 
Marker_GetNonSequentialTable( String format, Integer size ) RETURNS: LuaTable =>Returns a fixed size table of markers from the world builder. Markers that do not exist in the WB, will be nil in the table. This is why we call it 'non-sequential'. 
Marker_GetNumberAttribute( ScarMarker marker, const char * name ) RETURNS: float =>Returns a generic number attribute defined in a marker. 
Marker_GetPosition( ScarMarker marker ) RETURNS: ScarPosition =>Returns the position of a given marker. 
Marker_GetProximityRadius( ScarMarker marker ) RETURNS: float =>Returns the proximity radius of a given marker. Only for marker with proximity type PT_Circle. This value gets set in the Mission Editor. 
Marker_GetProximityType( ScarMarker marker ) RETURNS: MarkerObj::ProximityType =>Returns the proximity type of a given marker. The possible results are PT_Circle and PT_Rectangle. 
Marker_GetSequence( String name, String type ) RETURNS: Table =>Builds a table of MarkerIDs that are named in a sequence. i.e. a name of "spot" will find markers "spot1", "spot2" and so on, up until it looks for a marker that isn't there. 
Marker_GetStringAttribute( ScarMarker marker, const char * name ) RETURNS: std::string =>Returns a generic string attribute defined in a marker. 
Marker_GetTable( String format ) RETURNS: LuaTable =>Returns a table of markers from the world builder. Creates as many as it finds. 
Marker_GetType( ScarMarker marker ) RETURNS: const char * =>Returns the typename of a given marker. This is the typename from the Mission Editor (name displayed when placing markers) 
Marker_InProximity( ScarMarker marker, ScarPosition pos ) RETURNS: bool =>Returns true if the given position is in the markers proximity radius or proximity rectangle (depending on the type). 
MergeClone( Table defaultTable, Table overrideTable ) RETURNS: Table =>Merge clones two table (recursively) into a single table combining into a new table allowing for unadulterated use of the data. 
MergeCloneTable( Table modifyGoalData ) RETURNS: Void =>Adjust default goal data. Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter goal values. 
Misc_DoWeaponHitEffectOnPosition( ScarPosition pos, ScarWeaponPBG weaponPBG, bool penetrated ) RETURNS: void =>Do weapon hit effect on the ground. 
Misc_GetScarFullFilename(  ) RETURNS: const char * =>Returns the full path name to the main SCAR script. 
Misc_GetTerrainHeight( ScarPosition p ) RETURNS: float =>Returns the terrain height at the top-down co-ordinate specified (for terrain entities can walk on only) 
Misc_IsEGroupOnScreen( EGroupID group, Real percent, Boolean all ) RETURNS: Void =>Test whether ANY or ALL of an EGroup is on screen currently (not strict) 
Misc_IsEGroupSelected( EGroupID egroup, Boolean all ) RETURNS: Boolean =>Returns true if ANY or ALL of the EGroup is selected. 
Misc_IsSGroupOnScreen( SGroupID group, Real percent, Boolean all ) RETURNS: Void =>Test whether ANY or ALL of an SGroup is on screen currently (not strict) 
Misc_IsSGroupSelected( SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Returns true if ANY or ALL of the SGroup is selected. 
Misc_ToggleEntities(  ) RETURNS: void =>Hide all world entities for NIS performance debugging. 
Modifier_IsEnabledOnEGroup( EGroupID egroup, String modifier, String modtype, Boolean all, Boolean bEnabledByDefault ) RETURNS: Void =>Checks if a modifier is enabled on all or any entities in an egroup. 
Modifier_Remove( ModID modifier ) RETURNS: Void =>Remove an applied modifier. 
Modifier_RemoveAllFromEGroup( EGroupID egroup ) RETURNS: Void =>Removes all SCAR-applied modifiers for a specific EGroup. 
Modifier_RemoveAllFromSGroup( SGroupID sgroup ) RETURNS: Void =>Removes all SCAR-applied modifiers for a specific SGroup. 
Modify_AbilityDelayTime( PlayerID player, AbilityID ability, Real scalefactor ) RETURNS: ModID =>Modifies the initial delay time of an ability. 
Modify_AbilityDurationTime( PlayerID player, AbilityID ability, Real scalefactor ) RETURNS: ModID =>Modifies the duration of an ability. 
Modify_AbilityManpowerCost( PlayerID player, AbilityID ability, Real scalefactor, Integer mathtype ) RETURNS: ModID =>Modifies the manpower cost of an ability. 
Modify_AbilityMaxCastRange( PlayerID player, AbilityID ability, Real scalefactor ) RETURNS: ModID =>Modifies the maximum casting range of an ability. NOTE: it assumes that the actions that the ability executes can also handle the modified range. 
Modify_AbilityMinCastRange( PlayerID player, AbilityID ability, Real scalefactor ) RETURNS: ModID =>Modifies the minimum casting range of an ability. NOTE: it assumes that the actions that the ability executes can also handle the modified range. 
Modify_AbilityMunitionsCost( PlayerID player, AbilityID ability, Real scalefactor, Integer mathtype ) RETURNS: ModID =>Modifies the munitions cost of an ability. 
Modify_AbilityRechargeTime( PlayerID player, AbilityID ability, Real scalefactor, Integer mathtype ) RETURNS: ModID =>Modifies the recharge time of an ability. 
Modify_Armor( SGroupID/EGroupID group, Real scalefactor, Boolean exclusive ) RETURNS: ModID =>Modifies a squad or entity's armor. 
Modify_CaptureTime( EGroupID sgroup, Real scalefactor ) RETURNS: ModID =>Modifies the capture time of all strategic points in an EGroup. DO NOT USE THIS FUNCTION. 
Modify_DisableHold( EGroupID group, Boolean disable ) RETURNS: ModID =>Enable or disable hold (garrisoning) for an egroup or sgroup. 
Modify_Enable_ParadropReinforcements( PlayerID playerId, Boolean enable ) RETURNS: Void =>Allows paratroopers to reinforce from the sky. Set to true to enable, false to disable. 
Modify_EntityBuildTime( PlayerID playerId, String ebp, Real scalefactor ) RETURNS: ModID =>Modifies the time taken to build a particular EBP. This only affects the given player. 
Modify_EntityCost( PlayerID player, String blueprint, Integer resourcetype, Integer addition ) RETURNS: ModID =>Modifies the cost of an entity for a particular player. Possible resource types are RT_Manpower, RT_Munition, RT_Fuel, RT_Action. 
Modify_PlayerExperienceReceived( PlayerID player, Real factor ) RETURNS: ModID =>Modifies the veterancy experience received by a player. 
Modify_PlayerProductionRate( PlayerID sgroup, Real scalefactor ) RETURNS: ModID =>Modifies the production rate of a player. 
Modify_PlayerResourceCap( PlayerID playerId, Integer resourceType, Real scalefactor, Integer mathtype ) RETURNS: ModID =>Modifies a player's resource cap. Possible resource types are RT_Manpower, RT_Munition, RT_Fuel. Possible math types are MUT_Multiplication, MUT_Addition. 
Modify_PlayerResourceGift( PlayerID playerId, Integer resourceType, Real scalefactor ) RETURNS: ModID =>Modifies a player's resource bonus received (ie. one-time resource gifts) Possible resource types are RT_Manpower, RT_Munition, RT_Fuel, RT_Action. 
Modify_PlayerResourceRate( PlayerID playerId, Integer resourceType, Real scalefactor, Integer mathtype ) RETURNS: ModID =>Modifies a player's incoming resource rate. Possible resource types are RT_Manpower, RT_Munition, RT_Fuel, RT_Action. Possible math types are MUT_Multiplication, MUT_Addition. 
Modify_PlayerSightRadius( PlayerID player, Real scalefactor ) RETURNS: ModID =>Modifies the sight radius for a player. 
Modify_ProductionRate( EGroupID sgroup, Real scalefactor ) RETURNS: ModID =>Modifies the production rate of all factories in an EGroup. 
Modify_ProductionSpeed( Entity entity, Real scalefactor ) RETURNS: ModID =>Modifies the build time for a particular upgrade. This only affects the given player. 
Modify_ProjectileDelayTime( PlayerID player, PBG entityBP, Real factor ) RETURNS: ModID =>Modifies a projectile's delay_detonate_time. 
Modify_ReceivedAccuracy( SGroupID/EGroupID group, Real scalefactor, Boolean exclusive ) RETURNS: ModID =>Modifies the chance of a squad/entity being hit. 
Modify_ReceivedDamage( SGroupID/EGroupID group, Real scalefactor, Boolean exclusive ) RETURNS: ModID =>Modifies the damage a squad/entity receives. 
Modify_ReceivedSuppression( SGroupID sgroup, Real scalefactor ) RETURNS: ModID =>Modifies the rate at which a squad gets suppressed. 
Modify_SetUpgradeCost( PlayerID playerId, UpgradeID upgrade, Integer resourceType, Real newCost ) RETURNS: ModID =>Sets the cost of an upgrade. This only affects the given player. 
Modify_SightRadius( SGroupID/EGroupID group, Real scalefactor ) RETURNS: ModID =>Modifies the sight radius for an egroup or an sgroup. 
Modify_SquadAvailability( PlayerID player, String blueprint, Integer addition ) RETURNS: ModID =>Modifies the availability limit of a squad type for any given player. 
Modify_SquadCaptureRate( SGroupID group, Real scalefactor ) RETURNS: ModID =>Modifies a squad's rate at which it will capture a strategic point. 
Modify_SquadTypeSightRadius( PlayerID player, String blueprint, Real scalefactor ) RETURNS: ModID =>Modifies the sight radius of a squad type for any given player. 
Modify_TargetPriority( SGroupID/EGroupID group, Integer addition ) RETURNS: ModID =>Modifies the target priority of a squad or entity group from the attacker. The value is an addition. 
Modify_TeamWeapon( SGroupID/EGroupID group, String modifier, Real scalefactor, String hardpoint ) RETURNS: ModID =>Modifies a sync weapon only. 
Modify_TerritoryRadius( EGroupID group, Real scalefactor ) RETURNS: ModID =>Modifies the territory radius for an egroup or an sgroup. 
Modify_UnitSpeed( SGroupID sgroup, Real scalefactor ) RETURNS: ModID =>Modifies the maximum speed for a vehicle. This has no effect on infantry. 
Modify_UnitVeterancyValue( SGroup/EGroup group, Real scalefactor, Integer mathtype, exclusive  ) RETURNS: ModID =>Modifies the Veterancy Experience value of the target SGroup, EGroup, Entity, or Squad. Mathtype is Multiplication by default. 
Modify_UpgradeBuildTime( PlayerID playerId, UpgradeID upgrade, Real scalefactor ) RETURNS: ModID =>Modifies the build time for a particular upgrade. This only affects the given player. 
Modify_Upkeep( PlayerID playerId, Real scalefactor ) RETURNS: ModID =>Modifies the upkeep for a player. 
Modify_VehicleRepairRate( PlayerID player, Real factor, String engineer_entity_blueprint ) RETURNS: ModID =>Modifies the vehicle repair rate of all a player's engineers. 
Modify_VehicleRotationSpeed( EGroupID/SGroupID group, Real factor ) RETURNS: ModID =>Modifies the vehicle rotation speed. 
Modify_VehicleTurretRotationSpeed( SGroupID/EGroupID group, String hardpoint, Real scalefactor ) RETURNS: ModID =>Modifies the turret rotation speed of a vehicle squad. 
Modify_Vulnerability( EGroupID/SGroupID group, Real scalefactor ) RETURNS: ModID =>Increases the received accuracy, penetration, and damage on a squad by the scalefactor. For example, a scalefactor of 2 means that the squad gets 2x the received accuracy, 2x the received penetration, and 2x the received damage. 
Modify_WeaponAccuracy( SGroupID/EGroupID group, String hardpoint, Real scalefactor ) RETURNS: ModID =>Modifies a squad's weapon accuracy. 
Modify_WeaponBurstLength( SGroupID/EGroupID group, String hardpoint, Real scalefactor ) RETURNS: ModID =>Modifies a squad's weapon burst length (time). 
Modify_WeaponBurstRateOfFire( SGroupID/EGroupID group, String hardpoint, Real scalefactor ) RETURNS: ModID =>Modifies a squad's weapon rate of fire. 
Modify_WeaponCooldown( SGroupID/EGroupID group, String hardpoint, Real scalefactor ) RETURNS: ModID =>Modifies a squad's weapon cooldown time. 
Modify_WeaponDamage( SGroupID/EGroupID group, String hardpoint, Real scalefactor ) RETURNS: ModID =>Modifies a squad's weapon damage. 
Modify_WeaponEnabled( SGroupID/EGroupID group, String hardpoint, Boolean enabled ) RETURNS: ModID =>Enables or disables a weapon hardpoint. 
Modify_WeaponPenetration( SGroupID/EGroupID group, String hardpoint, Real scalefactor ) RETURNS: ModID =>Modifies a squad's weapon penetration. Does not work on artillery (mortar, nebelwerfer, etc.) 
Modify_WeaponRange( SGroupID/EGroupID group, String hardpoint, Real scalefactor ) RETURNS: ModID =>Modifies a squad's weapon range. Does not work on artillery (mortar, nebelwerfer, etc.) 
Modify_WeaponReload( SGroupID/EGroupID group, String hardpoint, Real scalefactor ) RETURNS: ModID =>Modifies a squad's weapon reload time. 
Modify_WeaponScatter( SGroupID/EGroupID group, String hardpoint, Real scalefactor ) RETURNS: ModID =>Modifies a squad's weapon scatter. 
Modify_WeaponSuppression( SGroupID/EGroupID group, String hardpoint, Real scalefactor ) RETURNS: ModID =>Modifies a squad's weapon suppression. Does not work on artillery (mortar, nebelwerfer, etc.) 
ModMisc_MakeCasualtyAction( Entity * pTargetEntity ) RETURNS: void =>Make the passed entity a casualty by triggering the MakeCasualtyAction. 
ModMisc_OOCAction( Entity * pTargetEntity ) RETURNS: void =>Make the passed entity go out of control. 
MP_BlizzardInit( String blizzard_atmosphere, String default_atmosphere, Boolean startInBlizzard, Table blizzardData, Boolean useSpeech, String transitionOutAtmosphere ) RETURNS: Void =>Initializes and starts cold weather and blizzard mechanics, taking in atmosphere presets to use in each condition. Uses MP values by default. Defaults to NOT starting in blizzard conditions. 
Objective_AddPing( LuaTable objectiveTable, Position pos ) RETURNS: PingID =>Adds a tactical map ping to an objective. 
Objective_AddUIElements( LuaTable objTable, Position pos, Boolean ping, LocString hintpointText, Boolean worldArrow, Float/Position objectiveArrowOffset, Entity/Squad/Position objectiveArrowFacing, HintPointActionType actionType, String iconName ) RETURNS: ElementID =>Adds multiple UI elements on one position. 'pos' can be group/entity/squad/marker. worldArrow adds a 3D arrow which points to the thing in the world. hintpointText adds a hint point that appears on the thing when moused over. If you're adding an arrow or a hintpoint, this thing will be among those potentially pointed to by the 2D HUD arrow. objectiveArrowOffset is an offset applied to the arrow's position (you can specify a height offset or a 3D position offset). 
Objective_AreAllPrimaryObjectivesComplete( none  ) RETURNS: Boolean =>Returns whether all primary objectives have been completed. 
Objective_Complete( LuaTable objTable, Boolean bShowTitle, Boolean skipIntel ) RETURNS: Void =>'Completes' an objective. Wrapper function for Objective_SetState with a few other features. If you do not want the objective title to be shown on screen, pass in 'false' for bShowTitle 
Objective_Fail( LuaTable objTable, Boolean bShowTitle, Boolean skipIntel ) RETURNS: Void =>'Fails' an objective. Wrapper function for Objective_SetState with a few other features. 
Objective_GetCounter( LuaTable objTable ) RETURNS: Integer =>Returns the current count associated with this objective. 
Objective_GetTimerSeconds( LuaTable objTable ) RETURNS: Integer =>Returns the amount of seconds on the timer (time remaining or time elapsed, based on the type of timer used) 
Objective_IncreaseCounter( LuaTable objTable, Int amount ) RETURNS: Void =>Increases the counter that is associated with this objective in the UI. You can provide an amount to increase by. 
Objective_IsComplete( LuaTable objTable ) RETURNS: Boolean =>Returns whether an objective is complete. 
Objective_IsCounterSet( LuaTable objTable ) RETURNS: Boolean =>Returns true if a counter has been set for this objective. 
Objective_IsFailed( LuaTable objTable ) RETURNS: Boolean =>Returns whether an objective is failed. 
Objective_IsStarted( LuaTable objTable ) RETURNS: Boolean =>Returns whether an objective has been started. Completed objectives will return true. 
Objective_IsTimerSet( LuaTable objTable ) RETURNS: Boolean =>Returns true if a timer has been set for this objective. 
Objective_IsVisible( LuaTable objTable ) RETURNS: Boolean =>Returns whether an objective is visible or not. 
Objective_PauseTimer( LuaTable objTable ) RETURNS: Void =>Pauses the objective's timer. If a timer has not been set, it does nothing. 
Objective_Register( LuaTable objTable, PlayerID/TeamID owner ) RETURNS: ObjectiveID =>'Registers' an objective. Wrapper function for Objective_Create with a few other features. 
Objective_RemovePing( LuaTable objectiveTable, Integer PingID ) RETURNS: Void =>Removes a tactical map ping from an objective. 
Objective_RemoveUIElements( LuaTable objTable, Integer elementID ) RETURNS: Void =>Removes a group of UI elements that were added by Objective_AddUIElements. 
Objective_ResumeTimer( LuaTable objTable ) RETURNS: Void =>Resume the objective's timer. If a timer has not been set, it does nothing. 
Objective_SetAlwaysShowDetails( LuaTable objTable, Boolean title, Boolean hud_arrow, Boolean hintpoints ) RETURNS: Void =>Sets whether this objective always shows detailed text, the HUD arrow, or the hintpoints. There can only be one objective at a time that forces the HUD arrow to show up. If you pass in 'nil' for hud_arrow then its behavior is not affected. 
Objective_SetCounter( LuaTable objTable, Float current, Float maximum ) RETURNS: Void =>Sets a counter that is associated with this objective in the UI. You can provide a 'maximum' so that it shows up as "1 of 5". 
Objective_Show( LuaTable objective_table, Boolean on/ off ) RETURNS: Void =>Shows or hides an objective from the UI and tactical map. 
Objective_Start( LuaTable objTable, Boolean bShowTitle, Boolean skipIntel ) RETURNS: Void =>Shows an objective to the player and activates it. 
Objective_StartTimer( LuaTable objTable, Integer direction, Float initialTime, Float flashThreshold ) RETURNS: Void =>Starts a timer that is associated with this objective in the UI. Use COUNT_DOWN or COUNT_UP for the 'direction' parameter. 
Objective_StopCounter( LuaTable objTable ) RETURNS: Void =>Stops the objective's counter. If a counter has not been set, it does nothing. 
Objective_StopTimer( LuaTable objTable ) RETURNS: Void =>Stops the objective's timer. If a timer has not been set, it does nothing. 
Objective_TogglePings( LuaTable objective_table, Boolean on/ off ) RETURNS: Void =>Toggles minimap blips on or off. 
Objective_UpdateText( LuaTable objTable, LocString title, LocString description, Boolean bShowTitle ) RETURNS: Void =>Updates the title and description for the objective. If you only want to set one of them, pass in nil for the other. 
Order227_Init( Integer timeLimit, Integer timeBetweenShots, Boolean noMercy ) RETURNS: Void =>Enable the HQ Commissar in CoH2 campaign missions. The noMercy flag allows the Commissar to execute more than one member of each squad. 
Player_AddAbility( ModPlayer * pPlayer, ScarAbilityPBG pAbilityPBG ) RETURNS: void =>Add an ability to a player. 
Player_AddAbilityLockoutZone( ModPlayer * player, ScarAbilityPBG abilityPBG, ScarMarker marker ) RETURNS: void =>Specifies a marker where an ability cannot be used. This only applies to abilities where you use the cursor to pick a location in the world (like a location to paradrop at). 
Player_AddResource( PlayerID playerId, Integer resourceType, Real value ) RETURNS: Void =>Add resource to player, as opposed to just setting it. Possible resource types are RT_Manpower, RT_Munition, RT_Fuel, RT_Action. 
Player_AddSquadsToSGroup( PlayerID playerId, String squadgroupName ) RETURNS: SGroupID =>For the given player, get all of the squads gathered into a squadgroup of your naming. 
Player_AddUnspentCommandPoints( ModPlayer * player, float points ) RETURNS: void =>Gives the player new command points to spent on. 
Player_AreSquadsNearMarker( PlayerID playerid, MarkerID marker ) RETURNS: Boolean =>Returns true if ANY of a players squads are in proximity of a marker. 
Player_CanCastAbilityOnEntity( ModPlayer * player, ScarAbilityPBG abilityPBG, Entity * targetEntity ) RETURNS: bool =>Tests if the player can currently use an ability on target entity. 
Player_CanCastAbilityOnPlayer( ModPlayer * player, ScarAbilityPBG abilityPBG, ModPlayer * targetPlayer ) RETURNS: bool =>Tests if the player can currently use an ability on target player. 
Player_CanCastAbilityOnPosition( ModPlayer * player, ScarAbilityPBG abilityPBG, ScarPosition targetPosition ) RETURNS: bool =>Tests if the player can currently use an ability on target position. 
Player_CanCastAbilityOnSquad( ModPlayer * player, ScarAbilityPBG abilityPBG, Squad * targetSquad ) RETURNS: bool =>Tests if the player can currently use an ability on target squad. 
Player_CanConstructOnPosition( PlayerID player, SGroup sgroupid, Entity ebp, EGroupID/Position/Marker targetid, Position Facing ) RETURNS: Boolean =>Returns TRUE if player can construct the specified entity at specified position and facing. Otherwise, returns FALSE. 
Player_CanPlaceStructureOnPosition( Player * player, SGroup * sgroup, ScarEntityPBG ebp, ScarPosition position, ScarPosition facing ) RETURNS: bool =>Check if a player of specified group can place an entity at the specified position and facing angle. 
Player_CanSeeEGroup( PlayerID playerid, EGroupID egroup, Boolean all ) RETURNS: Boolean =>Returns true if a player can see ALL or ANY items in an egroup. 
Player_CanSeeEntity( const ModPlayer * player, Entity * entity ) RETURNS: bool =>Returns true if a player can see a given entity (revealed in FOW) 
Player_CanSeePosition( const ModPlayer * player, ScarPosition pos ) RETURNS: bool =>Returns true if a player can see a given position. 
Player_CanSeeSGroup( PlayerID playerid, SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Returns true if a player can see ALL or ANY items in an sgroup. 
Player_CanSeeSquad( const ModPlayer * player, Squad * squad, bool all ) RETURNS: bool =>Returns true if a player can see ALL or ANY units in a given squad (revealed in FOW) 
Player_ClearArea( PlayerID player, MarkerID marker, Bool invulnerable ) RETURNS: Void =>Any of the player's units in the marker area move out of the area, and can be made invulnerable for a bit whilst they do it. 
Player_ClearAvailabilities( ModPlayer * player ) RETURNS: void =>Clears item, command and construction menu availabilities for the player. 
Player_ClearPopCapOverride( ModPlayer * player ) RETURNS: void =>Clears the pop cap override so that modifiers can take effect again. 
Player_CompleteUpgrade( ModPlayer * pPlayer, ScarUpgradePBG pUpgradePBG ) RETURNS: void =>Finish upgrade for a player. 
Player_FindFirstEnemyPlayer( const ModPlayer * player ) RETURNS: ModPlayer * =>Searches the player list in the world and returns the id of the first enemy player. 
Player_FromId( uint32_t id ) RETURNS: ModPlayer * =>Returns a player given a player id from the ME. 
Player_GetAIType( ModPlayer * pPlayer ) RETURNS: Player::AIType =>Returns the type of the given player if it is an AI. 
Player_GetAll( PlayerID player, SGroupID sgroup, EGroupID egroup ) RETURNS: Void =>Creates/Clears groups that contain all of a player's units and buildings. Defaults - sg_allsquads and eg_allentities. 
Player_GetAllEntitiesNearMarker( PlayerID playerid, EGroupID egroup, MarkerID/Pos/SectorID position, Real range ) RETURNS: Void =>Gather together all of a player's entities that are in proximity to a marker, a position, or within a territory sector into an EGroup. The EGroup is cleared beforehand. 
Player_GetAllSquadsNearMarker( PlayerID player, SGroupID sgroup, MarkerID/Pos/SectorID position, Real range ) RETURNS: Void =>Gather together all of a player's squads that are in proximity to a marker, a position, or within a territory sector into an SGroup. The SGroup is cleared beforehand. 
Player_GetBuildingID( PlayerID player, BlueprintTable entitytypes ) RETURNS: EntityID =>Returns the entityID of the first player owned building listed in the table. 
Player_GetBuildingsCount( PlayerID playerId ) RETURNS: Integer =>Returns the total number of buildings owned by this player. 
Player_GetBuildingsCountExcept( PlayerID playerId, BlueprintTable exceptions ) RETURNS: Integer =>Returns the total number of buildings owned by this player (with exclusions). 
Player_GetBuildingsCountOnly( PlayerID playerId, BlueprintTable ebplist ) RETURNS: Integer =>Returns the number of buildings owned by this player (inclusive). 
Player_GetCurrentPopulation( const ModPlayer * player, CapType capType ) RETURNS: float =>Use capType CT_Personnel to get current squad cap, CT_Vehicle to get current vehicle cap, CT_Medic to get current medic cap. 
Player_GetDisplayName( const ModPlayer * player ) RETURNS: LocString =>Returns the players UI name. 
Player_GetEntities( ModPlayer * player ) RETURNS: EGroup * =>Returns an EntityGroupObs containing all the players entities. 
Player_GetEntitiesFromType( PlayerID player, String unitType ) RETURNS: EGroup =>Returns an EGroup containing all of the players entities of a specific unit_type (as defined by the type_ext on the entity) 
Player_GetEntityConcentration( PlayerID player, Boolean popcapOnly, Table includeBlueprints, Table excludeBlueprints, Boolean bLeastConcentrated, MarkerID/Table onlyInThisMarker ) RETURNS: EGroup =>Finds the greatest (or least) concentration of entities owned by a player. 
Player_GetEntityCount( const ModPlayer * player ) RETURNS: int =>Returns the number of entities a player currently owns. 
Player_GetEntityName( const ModPlayer * player, int index ) RETURNS: const char * =>Returns the name of an entity a player currently owns. 
Player_GetFatalityFunctionName( const ModPlayer * player ) RETURNS: const char * =>Returns the player's post-game fatality function name (as defined in Fatalities.scar) 
Player_GetID( const ModPlayer * player ) RETURNS: int =>Returns the id of the player. 
Player_GetMaxPopulation( const ModPlayer * player, CapType capType ) RETURNS: float =>Use capType CT_Personnel to get max squad cap or CT_VehicleCap to get max vehicle cap. 
Player_GetNumStrategicPoints( const ModPlayer * p ) RETURNS: int =>Returns the number of strategic points (not objectives) this player owns. 
Player_GetNumVictoryPoints( const ModPlayer * p ) RETURNS: int =>Returns the number of strategic objectives this player owns. 
Player_GetPopulationPercentage( PlayerID playerid, Integer captype ) RETURNS: Real =>Gets the current personnel or vehicle population as a percetange of the current max-cap. The captype is either CT_Personnel or CT_Vehicle. 
Player_GetRace( const ModPlayer * player ) RETURNS: ScarRacePBG =>Returns the race for the given player. 
Player_GetRaceName( const ModPlayer * player ) RETURNS: const char * =>Returns the name of the race for a given player (always in english) 
Player_GetRelationship( const ModPlayer * player1, ModPlayer * player2 ) RETURNS: ModAlliance::AllianceResult =>Returns the relationship between 2 players. 
Player_GetResource( const ModPlayer * player, ResourceAmount::ResourceType type ) RETURNS: float =>Returns the amount of resources a given player has. 
Player_GetResourceRate( const ModPlayer * player, ResourceAmount::ResourceType type ) RETURNS: float =>Returns the amount of resources a given player is getting per second. 
Player_GetSquadBPCost( const ModPlayer * pPlayer, const PropertyBagGroup * pbg ) RETURNS: ResourceAmount =>Returns the modified cost of the given unit including all modifications added by the given player. 
Player_GetSquadConcentration( PlayerID player, Boolean popcapOnly, Table includeBlueprints, Table excludeBlueprints, Boolean bLeastConcentrated, MarkerID/Table onlyInThisMarker ) RETURNS: SGroup =>Finds the greatest (or least) concentration of squads owned by a player. 
Player_GetSquadCount( const ModPlayer * player ) RETURNS: int =>Returns the number of squads a player currently owns. 
Player_GetSquads( const ModPlayer * player ) RETURNS: SGroup * =>Returns a SquadGroupObs containing all the players units. 
Player_GetStartingPosition( const ModPlayer * player ) RETURNS: ScarPosition =>Returns the starting position for this player. 
Player_GetStrategicPointCaptureProgress( Player * player, Entity * strategicPoint ) RETURNS: float =>Returns a value (-1.0 to 1.0) of how close a point is to being controlled by the team of the player provided. 
Player_GetTeam( const ModPlayer * p ) RETURNS: int =>Get the team a player is on. 
Player_GetUnitCount( const ModPlayer * player ) RETURNS: int =>Returns the current number of units the player has. 
Player_GetUpgradeCost( ModPlayer * player, ScarUpgradePBG upgradePBG, ResourceAmount::ResourceType resourceType ) RETURNS: float =>Returns the cost of an upgrade. 
Player_HasAbility( ModPlayer * pPlayer, ScarAbilityPBG pAbilityPBG ) RETURNS: bool =>Tests to see if a player has an ability. 
Player_HasBuilding( PlayerID player, BlueprintTable entitytypes ) RETURNS: boolean =>Returns true if this player owns any buildings listed in the table. 
Player_HasBuildingsExcept( PlayerID playerId, BlueprintTable exceptions ) RETURNS: boolean =>Returns true if this player owns any buildings. (with exclusions). 
Player_HasBuildingUnderConstruction( PlayerID player, BlueprintTable entitytypes ) RETURNS: boolean =>Returns true if this player owns any buildings listed in the table currently under construction. 
Player_HasCapturingSquadNearStrategicPoint( Player * player, Entity * strategicPoint ) RETURNS: bool =>Returns true if the given player has units that are able to capture in the capturable area of the given strategic point. 
Player_HasMapEntryPosition( ModPlayer * player ) RETURNS: bool =>Returns whether a player has a map entry position. 
Player_HasUpgrade( const ModPlayer * pPlayer, ScarUpgradePBG upgradePBG ) RETURNS: bool =>Return true if the squad has purchased the specified upgrade. 
Player_IsAlive( const ModPlayer * player ) RETURNS: bool =>Returns true if player is still alive and false if player is dead. Will error if playerIdx is an invalid index. 
Player_IsAllied( PlayerID playerId1, PlayerID playerId2 ) RETURNS: Boolean =>Returns true if the players are allied and false if they are not. 
Player_IsHuman( ModPlayer * pPlayer ) RETURNS: bool =>Returns whether a player is human controlled (local or remote), not dead, and not replaced by an AI. 
Player_IsSurrendered( const ModPlayer * player ) RETURNS: bool =>Returns true if player has surrendered and false if not. Will error if playerIdx is an invalid index. 
Player_NumUpgradeComplete( const ModPlayer * player, ScarSquadPBG upgradePBG ) RETURNS: int =>Returns the number of upgrades that this player has. 
Player_OwnsEGroup( PlayerID playerid, EGroupID egroup, Boolean all ) RETURNS: Boolean =>Returns true if a given player owns ALL or ANY items in a group. 
Player_OwnsEntity( PlayerID playerid, EntityID entity ) RETURNS: Boolean =>Returns true if a given player owns an entity. 
Player_OwnsSGroup( PlayerID playerid, SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Returns true if a given player owns ALL or ANY items in a group. 
Player_OwnsSquad( PlayerID playerid, SquadID squad ) RETURNS: Boolean =>Returns true if a given player owns a squad. 
Player_RemoveAbilityLockoutZone( ModPlayer * player, ScarAbilityPBG abilityPBG, ScarMarker marker ) RETURNS: void =>Removes a marker that was previously a lockout zone. 
Player_RemoveUpgrade( ModPlayer * player, ScarUpgradePBG upgrade ) RETURNS: void =>Removes an upgrade from a player. 
Player_ResetResource( ModPlayer * player, ResourceAmount::ResourceType type ) RETURNS: void =>Reset the resource amount for a given player to zero. Also reset team weapon. 
Player_RestrictAddOnList( PlayerID playerid, Table addonlist ) RETURNS: Void =>Restrict a list of addons. 
Player_RestrictBuildingList( PlayerID playerid, Table blueprintlist ) RETURNS: Void =>Restrict a list of buildings. 
Player_RestrictResearchList( PlayerID playerid, StringTable list ) RETURNS: Void =>Restrict a list of research items. 
Player_SetAbilityAvailability( PlayerID player, AbilityBlueprint/Table bp, Integer availability ) RETURNS: Void =>Sets the availability of an ability. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT. 
Player_SetAllCommandAvailabilityInternal( ModPlayer * player, ModPlayer::Availability availability, LocString reason ) RETURNS: void =>Sets availability of ALL entity, squad and player commands. 
Player_SetCommandAvailability( PlayerID player, Integer/Table command, Integer availability ) RETURNS: Void =>Sets the availability of entity, squad and player commands. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT. 
Player_SetConstructionMenuAvailability( PlayerID player, String/Table menuname, Integer availability ) RETURNS: Void =>Sets the availability of a construction menu. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT. 
Player_SetDefaultSquadMoodMode( ModPlayer * pPlayer, SquadCombatBehaviourExt::MoodMode mood ) RETURNS: void =>Set default squad mood mode which can be overrided by squad level mood mode settings. 
Player_SetEntityProductionAvailability( PlayerID player, EntityBlueprint/Table bp, Integer availability ) RETURNS: Void =>Sets the availability of an entity production item. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT. 
Player_SetHeatGainRate( ModPlayer * player, float gainRatePerSecond ) RETURNS: void =>Set the heat gain rate per second for this player. Heat is gained when near a heat source or garrisoned. 
Player_SetHeatLossRate( ModPlayer * player, float lossRatePerSecond ) RETURNS: void =>Set the heat loss rate per second for this player. Heat is lost when not garrisoned and not near a heat source and not in valid cover. A value of 0 turns off the Cold System for all squads belonging to this player. It will also reset all squads to the default heat level. 
Player_SetMaxCapPopulation( PlayerID playerid, Integer captype, Integer newcap ) RETURNS: Void =>Sets the current personnel or vehicle max-cap for a player. The captype is either CT_Personnel or CT_Vehicle (you can't adjust Medic caps just yet). 
Player_SetMaxPopulation( PlayerID playerid, Integer captype, Integer newcap ) RETURNS: Void =>Sets the current personnel or vehicle cap for a player. The captype is either CT_Personnel or CT_Vehicle (you can't adjust Medic caps just yet). 
Player_SetPopCapOverride( ModPlayer * player, float personnel ) RETURNS: void =>Sets a pop cap override that ignores any modifiers. 
Player_SetResource( ModPlayer * player, ResourceAmount::ResourceType type, float amt ) RETURNS: void =>Set the resource amount for a given player. Ignores income cap and resource sharing. 
Player_SetSquadProductionAvailability( PlayerID player, SquadBlueprint/Table bp, Integer availability ) RETURNS: Void =>Sets the availability of a squad production item. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT. 
Player_SetUpgradeAvailability( PlayerID player, UpgradeBlueprint/Table bp, Integer availability ) RETURNS: Void =>Sets the availability of an upgrade. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT. 
Player_SetUpgradeCost( PlayerID player, UpgradeID upgrade, Real manpower, Real fuel, Real munition, Real action, Real command ) RETURNS: Void =>Sets the cost of an upgrade. 
Player_SpawnGlider( ModPlayer * player, ScarEntityPBG glider, ScarPosition start, ScarPosition end ) RETURNS: Entity * =>Spawns a glider and returns it. 
Player_StopAbility( ModPlayer * player, ScarAbilityPBG ability, bool bEarlyExit ) RETURNS: void =>Abruptly stops an active ability. 
Player_StopEarningActionPoints( PlayerID player ) RETURNS: Void =>Prevents a player from earning any action points (and by extention, command points) 
Player_Triangulate( ModPlayer * player, SGroup * squads, EGroup * eg ) RETURNS: void =>Returns the enemy squads and entities within a player's radio beacons. Radio beacons are shared among team members. 
Prox_AreEntitiesNearMarker( EGroupID egroup, MarkerID/Position/SectorID position, Boolean all, Real range ) RETURNS: Boolean =>Returns true if ANY or ALL entities from a group are in range of a given position, marker, or territory sector. 
Prox_ArePlayerMembersNearMarker( PlayerID player, MarkerID/Position/SectorID position, Boolean all, Real range, SBP/Table filterlist, Integer filtertype ) RETURNS: Boolean =>Returns true if ANY or ALL of a player's members (i.e. individual guys, not squads as a whole) are in range of a given position, marker, or territory sector. DO NOT USE THIS FUNCTION UNLESS YOU ABSOLUTELY HAVE TO!! 
Prox_ArePlayersNearMarker( PlayerID player, MarkerID/Position/SectorID position, Boolean all, Real range, SBP/Table filterlist, Integer filtertype ) RETURNS: Boolean =>Returns true if ANY or ALL of a player's squads are in range of a given position, marker, or territory sector. THIS FUNCTION IS VERY SLOW. DO NOT USE THIS UNLESS ABSOLUTELY NECESSARY. 
Prox_AreSquadMembersNearMarker( SGroupID sgroup, MarkerID/Position/SectorID position, Boolean all, Real range ) RETURNS: Boolean =>Returns true if ANY or ALL squad members (i.e. individual guys, not squads as a whole) from a group are in range of a given position, marker, or territory sector. DO NOT USE THIS FUNCTION UNLESS YOU ABSOLUTELY HAVE TO!! 
Prox_AreSquadsNearMarker( SGroupID sgroup, MarkerID/Position/SectorID position, Boolean all, Real range ) RETURNS: Boolean =>Returns true if ANY or ALL squads from a group are in range of a given position, marker, or territory sector. 
Prox_AreTeamsNearMarker( TeamID team, MarkerID/Position/SectorID position, Boolean all, Real range, SBP/Table filterlist, Integer filtertype ) RETURNS: Boolean =>Returns true if ANY or ALL of a teams's squads are in range of a given position, marker, or territory sector. THIS FUNCTION IS VERY SLOW. DO NOT USE THIS UNLESS ABSOLUTELY NECESSARY. 
Prox_EGroupEGroup( EGroupID egroup1, EGroupID egroup2, ProxType checktype ) RETURNS: Real =>Returns the distance between two entity groups. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER. 
Prox_EGroupSGroup( EGroupID egroup1, SGroupID sgroup2, ProxType checktype ) RETURNS: Real =>Returns the distance between an entity group and a squad group. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER. 
Prox_EntitiesInProximityOfEntities( EGroupID egroup1, EGroupID egroup2, Real proximity, Boolean all ) RETURNS: Boolean =>Checks if ALL or ANY entities are in proximity of a given entity group. 
Prox_GetRandomPosition( Object item, Integer radius, Integer minimum ) RETURNS: Position =>Takes something (Entity, Squad, SGroup, EGroup, Position) in, then returns a random position. 
Prox_MarkerEGroup( MarkerID marker, EGroupID egroup, ProxType checktype ) RETURNS: Real =>Returns the distance between a marker and an entity group. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER. 
Prox_MarkerSGroup( MarkerID marker, SGroupID sgroup, ProxType checktype ) RETURNS: Real =>Returns the distance between a marker and a squad group. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER. 
Prox_PlayerEntitiesInProximityOfEntities( PlayerID playerid, EGroupID egroup, Real proximity, Boolean all, EntityID exclude ) RETURNS: Boolean =>Checks if ALL or ANY players squads are in proximity of a given entity group. 
Prox_PlayerEntitiesInProximityOfPlayerSquads( PlayerID playerentities, PlayerID playersquads, Real proximity, Boolean all ) RETURNS: Boolean =>Checks if ALL or ANY players entities are in proximity of a given squad group. 
Prox_PlayerEntitiesInProximityOfSquads( PlayerID playerid, SGroupID sgroup, Real proximity, Boolean all ) RETURNS: Boolean =>Checks if ALL or ANY players entities are in proximity of a given squad group. 
Prox_PlayerSquadsInProximityOfEntities( PlayerID playerid, EGroupID egroup, Real proximity, Boolean all, SBP/Table filterlist, Int filtertype ) RETURNS: Boolean =>Checks if ALL or ANY players squads are in proximity of a given entity group. 
Prox_PlayerSquadsInProximityOfPlayerEntities( PlayerID playersquads, PlayerID playerentities, Real proximity, Boolean all ) RETURNS: Boolean =>Checks if ALL or ANY players squads are in proximity of a given players entities. 
Prox_PlayerSquadsInProximityOfPlayerSquads( PlayerID playerid1, PlayerID playerid2, Real proximity, Boolean all ) RETURNS: Boolean =>Checks if ALL or ANY players squads are in proximity of a given players squads. 
Prox_PlayerSquadsInProximityOfSquads( PlayerID playerid, SGroupID sgroup, Real proximity, Boolean all, SquadID exclude, SBP/Table filterlist, Int filtertype ) RETURNS: Boolean =>Checks if ALL or ANY players squads are in proximity of a given squad group. 
Prox_SGroupSGroup( SGroupID sgroup1, SGroupID sgroup2, ProxType checktype ) RETURNS: Real =>Returns the distance between two squad groups. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER. 
Prox_SquadsInProximityOfEntities( SGroupID sgroup, EGroupID egroup, Real proximity, Boolean all ) RETURNS: Boolean =>Checks if ALL or ANY squads are in proximity of a given entity group. 
Prox_SquadsInProximityOfSquads( SGroupID sgroup1, SGroupID sgroup2, Real proximity, Boolean all ) RETURNS: Boolean =>Checks if ALL or ANY squads are in proximity of a given squad group. 
Resources_Disable( Void  ) RETURNS: Void =>Disables any resource income - useful to stop resources accruing during the opening movie. 
Resources_Enable( Void  ) RETURNS: Void =>Re-enables resource income. 
Rule_Add( LuaFunction rule, Integer priority ) RETURNS: Void =>Add a rule to be executed every frame. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 
Rule_AddDelayedInterval( LuaFunction rule, Real delay, Real interval, Integer priority ) RETURNS: Void =>Add a rule to be executed at every 'interval' seconds, after an initial delay. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 
Rule_AddDelayedIntervalEx( LuaFunction rule, Real delay, Real interval, Integer calls, Integer priority, Integer calls ) RETURNS: Void =>Add a rule to be executed 'calls' times, at every 'interval' seconds, after an initial delay. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 
Rule_AddEGroupEvent( LuaFunction fule, EGroup egroup, Integer eventtype ) RETURNS: Void =>Add a rule to be executed when the event of 'eventType' has happened on the 'EGroup' Event types are: GE_EntityKilled. 
Rule_AddEGroupEvent( LuaFunction rule, EGroupID egroup, Integer eventtype ) RETURNS: Void =>Add a rule to be executed when the event of 'eventType' has happened on entities in the 'egroup'. 
Rule_AddEntityEvent( LuaFunction rule, EntityID entity, Integer eventtype ) RETURNS: Void =>Add a rule to be executed when the event of 'eventType' has happened on the 'entity'. 
Rule_AddGlobalEvent( LuaFunction rule, Integer eventtype ) RETURNS: Void =>Add a rule to be executed when the event of 'eventType' has happened, regardless of source. 
Rule_AddInterval( LuaFunction rule, Real interval, Integer priority ) RETURNS: Void =>Add a rule to be executed at every 'interval' seconds. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 
Rule_AddIntervalEx( LuaFunction rule, Real interval, Integer calls, Integer priority ) RETURNS: Void =>Add a rule to be executed 'calls' times, at every 'interval' seconds. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 
Rule_AddOneShot( LuaFunction rule, Real delay, Integer priority ) RETURNS: Void =>Add a rule to be executed once, after 'delay' seconds. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 
Rule_AddPlayerEvent( LuaFunction rule, PlayerID player, Integer eventtype ) RETURNS: Void =>Add a rule to be executed when the event of 'eventType' has happened on the 'player'. 
Rule_AddSGroupEvent( LuaFunction rule, SGroupID sgroup, Integer eventtype ) RETURNS: Void =>Add a rule to be executed when the event of 'eventType' has happened on squads in the 'sgroup'. 
Rule_AddSquadEvent( LuaFunction rule, SquadID squad, Integer eventtype ) RETURNS: Void =>Add a rule to be executed when the event of 'eventType' has happened on the 'squad'. 
Rule_ChangeInterval( LuaFunction rule, Real interval ) RETURNS: Void =>Change 'interval' seconds of an existing rule. 
Rule_Exists( LuaFunction rule ) RETURNS: Boolean =>Test if a rule is currently active. 
Rule_Remove( LuaFunction rule ) RETURNS: Void =>Remove a currently active rule (this does not remove any event rules) 
Rule_RemoveAll( Integer max_priority ) RETURNS: Void =>Kills all rules below a certain priority. The default is to remove ALL rules. 
Rule_RemoveEGroupEvent( LuaFunction rule, EGroupID egroup ) RETURNS: Void =>Remove an active event rule for entities in the 'egroup'. 
Rule_RemoveEntityEvent( LuaFunction rule, EntityID entity ) RETURNS: Void =>Remove an active event rule for the 'entity'. 
Rule_RemoveGlobalEvent( LuaFunction rule ) RETURNS: Void =>Remove an active event rule that's been applied 'globally'. 
Rule_RemoveIfExist( LuaFunction rule ) RETURNS: Void =>Remove a currently active rule if it exists(this does not remove any event rules) 
Rule_RemoveMe( Void  ) RETURNS: Void =>Remove a currently executing rule (only works inside a rule function) 
Rule_RemovePlayerEvent( LuaFunction rule, PlayerID player ) RETURNS: Void =>Remove an active event rule for the 'player'. 
Rule_RemoveSGroupEvent( LuaFunction rule, SGroupID sgroup ) RETURNS: Void =>Remove an active event rule for squads in the 'sgroup'. 
Rule_RemoveSquadEvent( LuaFunction rule, SquadID squad ) RETURNS: Void =>Remove an active event rule for the 'squad'. 
SBP_Exists( const char * pbgShortname ) RETURNS: bool =>Returns true if a squad blueprint exists with the given name. 
Scar_AddInit( LuaConfig::RefFunction f ) RETURNS: void =>Register an init function with the scar system. 
Scar_InitExists( LuaConfig::RefFunction f ) RETURNS: bool =>Returns true if an init function exists. 
Scar_RemoveInit( LuaConfig::RefFunction f ) RETURNS: void =>Unregister an init function that was registered from Scar_AddInit. 
Setup_Player( Integer playerIndex, LocString playerName, String playerRace, Integer team ) RETURNS: PlayerID =>Initializes the all of the players settings in one function and returns the playerID. 
SGroup_Add( SGroup * group, Squad * squadron ) RETURNS: void =>Adds an squadron to the end of a group if the group doesnt already have it. 
SGroup_AddAbility( SGroupID sgroup, AbilityBlueprint ability ) RETURNS: Void =>Adds an ability to all squads in an sgroup. 
SGroup_AddGroup( SGroup * group, SGroup * grouptoadd ) RETURNS: void =>Same as EGroup_AddGroup. Note: You cannot mix squad groups and entity groups. 
SGroup_AddGroups( SGroupID sgroup, Table groupList ) RETURNS: Void =>Add a list of multiple sgroups into an existing group. 
SGroup_AddLeaders( SGroupID sgroup ) RETURNS: Void =>Adds a leader to all squads in a group that can take a leader. 
SGroup_AddSlotItemToDropOnDeath( SGroupID groupid, Int itemid, Float drop_chance, Bool exclusive ) RETURNS: Void =>Add to the list of slot items to drop when any one of the squads is wiped out. 
SGroup_CanCastAbilityOnEntity( SGroupID caster, AbilityBlueprint ability, EntityID target_entity, Boolean all ) RETURNS: Void =>Test whether ANY or ALL of a group can be ordered to do this ability on the target squad. 
SGroup_CanCastAbilityOnPosition( SGroupID caster, AbilityBlueprint ability, Position position, Boolean all ) RETURNS: Void =>Test whether ANY or ALL of a group can be ordered to do this ability on the target position. 
SGroup_CanCastAbilityOnSquad( SGroupID caster, AbilityBlueprint ability, SquadID target_squad, Boolean all ) RETURNS: Void =>Test whether ANY or ALL of a group can be ordered to do this ability on the target entity. 
SGroup_CanInstantReinforceNow( SGroupID group, Boolean all ) RETURNS: Boolean =>Return true if ANY or ALL of a group can reinforce now. 
SGroup_CanSeeSGroup( SGroupID sgroup, SGroupID targetsgroup, Boolean all ) RETURNS: Boolean =>Returns true if ALL or ANY squads in a group can see ALL or ANY squads in a target sgroup. 
SGroup_Clear( SGroup * sgroup ) RETURNS: void =>Removes all entities from a group. 
SGroup_ClearPostureSuggestion( SGroup * sgroup ) RETURNS: void =>Clears any previous posture suggestions made to a squad. 
SGroup_Compare( SGroup * group1, SGroup * group2 ) RETURNS: bool =>Returns true if the contents of the two groups are equal. Order of the entities does not matter. 
SGroup_CompleteEntityUpgrade( SGroupID sgroup, UpgradeID upgrade ) RETURNS: Void =>Applies an upgrade to all squad entities in an sgroup. 
SGroup_ContainsBlueprints( SGroupID sgroup, BP/Table blueprints, Boolean all ) RETURNS: Boolean =>Check if a group contains ALL or ANY of the blueprints. 
SGroup_ContainsSGroup( SGroup * group1, SGroup * group2, bool all ) RETURNS: bool =>Returns true if SGroup1 contains ANY or ALL of SGroup2. 
SGroup_ContainsSquad( SGroup * group, uint32_t SquadID ) RETURNS: bool =>Returns true if SGroup contains a particular SquadID. 
SGroup_Count( SGroup * sgroup ) RETURNS: int =>Returns the total number of spawned and despawned squads in a group. 
SGroup_CountDeSpawned( SGroup * sgroup ) RETURNS: int =>Returns the number of despawned squads in a group. 
SGroup_CountSpawned( SGroup * sgroup ) RETURNS: int =>Returns the number of spawned squads in a group. 
SGroup_Create( const char * name ) RETURNS: SGroup * =>Returns a new squadron group with the given name. 
SGroup_CreateIfNotFound( String name ) RETURNS: SGroupID =>Find a squad group from name. Creates a new one with given name if it doesnt exist. 
SGroup_CreateKickerMessage( SGroupID group, PlayerID player, LocString textid ) RETURNS: Void =>Create and display kicker message on the each squad in the sgroup to the player. 
SGroup_CreateTable( String format, Integer size ) RETURNS: LuaTable =>Returns a table of sgroups NOT in the world builder. 
SGroup_DeSpawn( SGroupID groupid ) RETURNS: Void =>Despawn all spawned squads in a group. 
SGroup_Destroy( SGroup * egroup ) RETURNS: void =>Manually destroy a group that you dont need anymore. 
SGroup_DestroyAllInMarker( SGroupID sgroup, MarkerID marker ) RETURNS: Void =>Destroys all items in a group that are in proximity to a given marker. 
SGroup_DestroyAllSquads( SGroupID sgroup ) RETURNS: Void =>Destroys all spawned and despawned squads in a group. 
SGroup_DisableCombatPlans( SGroupID groupID ) RETURNS: Void =>Disables all current combat plans for the squads in the sgroup. 
SGroup_Duplicate( SGroupID sgroup1, SGroupID sgroup2 ) RETURNS: Void =>Duplicates an SGroup. 
SGroup_EnableAttention( SGroupID sgroup, Boolean attentive ) RETURNS: Void =>Sets whether an entity pays attention to its surroundings. 
SGroup_EnableMinimapIndicator( SGroupID group, Boolean enable ) RETURNS: Void =>Enable or disable minimap indicator on all squads in the sgroup. 
SGroup_EnableSurprise( SGroupID groupid, Boolean enable ) RETURNS: Void =>Enables or disables the surprise feature for an sgroup. 
SGroup_EnableUIDecorator( SGroupID group, Boolean enable ) RETURNS: Void =>Enable or disable decorators on all squads in the sgroup. 
SGroup_Exists( const char * name ) RETURNS: bool =>Returns true if the squad group with the given name exists. 
SGroup_FaceEachOther( SGroupID sgroup1, SGroupID sgroup2 ) RETURNS: Void =>Makes two SGroups face each other. 
SGroup_FaceMarker( SGroupID sgroup, MarkerID marker ) RETURNS: Void =>Makes a SGroup face a marker. 
SGroup_FacePosition( SGroup * sgroup, ScarPosition pos ) RETURNS: void =>Works like Squad_FacePosition. All Squads will face the same direction, with the squad the closest to the center determining the direction. 
SGroup_Filter( SGroupID sgroup, ID/Table blueprint, Integer filtertype, SGroupID splitSGroup ) RETURNS: Void =>Filters an SGroup by blueprint. 
SGroup_FilterCount( SGroupID sgroup1, Int groupSize ) RETURNS: Void =>Pass in a group and it will filter it down to the indicated number. 
SGroup_FilterThreat( SGroupID sgroup, LuaTable tableSBPs, Boolean bEmpty ) RETURNS: Void =>Searches an SGroup and finds the first threat within the table (searching first to last) and removes all other SBPs. 
SGroup_ForEach( SGroup * sgroup, LuaBinding::StackVarFunction f ) RETURNS: bool =>Call a lua function for each item in a group. Function will recieve (groupid, itemindex, itemid) and should return true to break or false to continue. 
SGroup_ForEachAllOrAny( SGroup * sgroup, bool all, LuaBinding::StackVarFunction f ) RETURNS: bool =>Call a lua function for each item in a group. Function will receive (groupid, itemindex, itemid) and should return a bool. 
SGroup_ForEachAllOrAnyEx( SGroup * sgroup, bool all, LuaBinding::StackVarFunction f, bool spawned, bool despawned ) RETURNS: bool =>Same as SGroup_ForEachAllOrAny except you have a choice to iterate over spawned squads, despawned squads, or both. 
SGroup_ForEachEx( SGroup * sgroup, LuaBinding::StackVarFunction f, bool spawned, bool despawned ) RETURNS: bool =>Same as SGroup_ForEach except you have a choice to iterate over spawned squads, despawned squads, or both. 
SGroup_FromName( const char * name ) RETURNS: SGroup * =>Find an squadron group with a given name. 
SGroup_GetAvgHealth( SGroupID sgroup ) RETURNS: Real =>Returns the average health of all units in a squad group. 
SGroup_GetAvgLoadout( SGroup sgroup ) RETURNS: Real =>Returns the average loadout of all squads in a group as a percent [0.0, 1.0]. 
SGroup_GetDeSpawnedSquadAt( SGroup * group, unsigned int index ) RETURNS: Squad * =>Returns the despawned squad at a certain position in the group. 
SGroup_GetGarrisonedBuildingEntity( SGroupID groupid ) RETURNS: EntityID =>Get the entity id of the building that any squad of the sgroup is garrisoned in. 
SGroup_GetHoldEGroup( SGroupID sgroup, EGroup EGroupHold ) RETURNS: Void =>Gets all the entities that an SGroup may occupy and adds them to the EGroupHold. 
SGroup_GetHoldSGroup( SGroupID sgroup, SGroup SGroupHold ) RETURNS: Void =>Gets all the squads that an SGroup may occupy and adds them to the SGroupHold. 
SGroup_GetInvulnerable( SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Check invulnerablity state for ALL or ANY squads in a squad group. 
SGroup_GetLastAttacker( SGroup SGroupVictim, SGroup SGroupAttacker, Real seconds ) RETURNS: Void =>Gets the last attacker(s) for all the squads in an SGroup Gets the last attacker for all the squads in an SGroup and stores that in SGroupAttacker. 
SGroup_GetLoadedVehicleSquad( SGroupID groupid ) RETURNS: SquadID =>Get the squad id of the vehicle squad that any squad of the sgroup is loaded in. 
SGroup_GetName( SGroup * sgroup ) RETURNS: const char * =>Returns the name of a given squad group. 
SGroup_GetNumSlotItem( SGroupID group, Int itemID ) RETURNS: Int =>Get the number of slot items with the same ID that the squads in the sgroup own. 
SGroup_GetOffsetPosition( SGroupID sgroup, Integer offset, Real value ) RETURNS: Position =>Returns a position (a certain distance away) relative to a squad's current position/orientation. see ScarUtil.scar for explanation of 'offset' parameter. 
SGroup_GetPosition( SGroup * group ) RETURNS: ScarPosition =>Returns the center position of a squad group. 
SGroup_GetRandomSpawnedSquad( SGroup sgroupid ) RETURNS: SquadID =>Get a random spawned squad from sgroup. 
SGroup_GetSequence( String name ) RETURNS: Table =>Builds a table of SGroupIDs that are named in a sequence. i.e. a name of "sg_killer" will find groups "sg_killer1", "sg_killer2" and so on, up until it looks for a group that isn't there. 
SGroup_GetSpawnedSquadAt( SGroup * group, unsigned int index ) RETURNS: Squad * =>Returns the spawned squad at a certain position in the group. 
SGroup_GetSpread( SGroupID sgroup ) RETURNS: Real =>Returns the distance from the centre of the group of the unit that furthest out. 
SGroup_GetSquadsHeld( SGroupID sgroup, SGroupID sgroupRecipient ) RETURNS: Void =>Returns an sgroup containing all squads held by any squad in an sgroup. 
SGroup_GetSuppression( SGroupID groupid ) RETURNS: Float =>Get the suppression level for the first squad in the sgroup. 
SGroup_GetVeterancyExperience( SGroupID groupid ) RETURNS: Float =>Get the veterancy experience value for the first squad in the sgroup. 
SGroup_GetVeterancyRank( SGroupID groupid ) RETURNS: Int =>Get the veterancy rank for the first squad in the sgroup. 
SGroup_GetWBTable( String format ) RETURNS: LuaTable =>Returns a table of sgroups from the world builder. 
SGroup_HasCritical( SGroupID group, CriticalID critical, Boolean all ) RETURNS: Boolean =>Returns true if ANY or ALL of the squads in the SGroup have the specified critical. 
SGroup_HasEntityUpgrade( EGroupID egroup, UpgradeID upgrade, Boolean all ) RETURNS: Boolean =>Returns true if ANY or ALL of the squad's entities have the specified upgrade. 
SGroup_HasLeader( SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Check if ALL or ANY squads in a sgroup have a leader. 
SGroup_HasSquadBlueprint( SGroupID sgroup, BP blueprint, Boolean all ) RETURNS: Boolean =>Check if ALL or ANY of the squads in a group have a specific blueprint. 
SGroup_HasTeamWeapon( SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Returns true if ANY or ALL of the squads in an SGroup are carrying some kind of team weapon. 
SGroup_HasUpgrade( SGroupID sgroup, UpgradeID upgrade, Boolean all ) RETURNS: Boolean =>Returns whether ANY or ALL squads in an SGroup have the specified upgrade. 
SGroup_Hide( SGroupID sgroup, Bool hide ) RETURNS: Void =>Hide or show all entities in all squads in an SGroup. 
SGroup_IncreaseVeterancyExperience( SGroupID groupid, Float experience, Boolean silent, Boolean applyModifiers ) RETURNS: Void =>Increase squad veterancy experience for all squads in the sgroup. Can do silent promotion (no sound/UI). Can skip modifiers, giving you direct control of experience gained. 
SGroup_IncreaseVeterancyRank( SGroupID groupid, Integer numranks, Boolean silent ) RETURNS: Void =>Increase squad veterancy rank for all squads in the sgroup. By default, increases rank by 1. Can do silent promotion (no sound/UI. ex: mass rank insrease at mission start) 
SGroup_Intersection( SGroup * group, SGroup * grouptointersect ) RETURNS: void =>Same as EGroup_Intersection. Note: You cannot mix squad groups and entity groups. 
SGroup_IsAlive( SGroupID sgroup ) RETURNS: Boolean =>Returns true if a named squad group is not empty and its average health is > 0.0. 
SGroup_IsAttackMoving( SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Returns true if ANY or ALL squads in an SGroup are attack moving. 
SGroup_IsCamouflaged( SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Returns true if ANY or ALL of the squads in an SGroup are camouflaged. 
SGroup_IsCapturing( SGroupID sgroup, Boolean ALL ) RETURNS: Boolean =>Checks if ANY or ALL squads in an SGroup are capturing. 
SGroup_IsConstructingBuilding( SGroup sgroup, Boolean all ) RETURNS: Boolean =>Returns true if ALL or ANY squads in a group are currently constructing a building. 
SGroup_IsDoingAbility( SGroupID sgroupid, AbilityID ability, Boolean all ) RETURNS: Boolean =>Returns if ANY or ALL members of an SGroup are doing an ability. 
SGroup_IsDoingAttack( SGroupID sgroup, Boolean all, Float time ) RETURNS: Boolean =>Returns true if ALL or ANY squads are attacking within the time. 
SGroup_IsDugIn( SGroupID group, Boolean all ) RETURNS: Boolean =>Returns true if ANY or ALL of the squads in the SGroup is dug in (or in the process of digging in) 
SGroup_IsEmpty( SGroupID sgroup ) RETURNS: Boolean =>Returns true if a named squad group is empty. 
SGroup_IsFemale( SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Returns true if ANY or ALL squads are female. 
SGroup_IsHoldingAny( SGroupID sgroup ) RETURNS: Void =>Returns whether any entity in an SGroup has a hold on anything. 
SGroup_IsIdle( SGroupID sgroup, Boolean ALL ) RETURNS: Boolean =>Checks if ANY or ALL squads in an SGroup are idle. 
SGroup_IsInCover( SGroupID sgroup, Boolean all ) RETURNS: Real Boolean =>Returns the percentage of the SGroup members that are in cover. Alternatively, specify ANY or ALL as a second parameter to return true/false. 
SGroup_IsInfiltrated( SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Returns true if ALL or ANY squads in a group are infiltrated. 
SGroup_IsInHoldEntity( SGroupID sgroup, Boolean ALL ) RETURNS: Boolean =>Checks if ANY or ALL squads in an SGroup are garrisoned in an entity (building) 
SGroup_IsInHoldSquad( SGroupID sgroup, Boolean ALL ) RETURNS: Boolean =>Checks if ANY or ALL squads in an SGroup are garrisoned in a squad (transport vehicle) 
SGroup_IsMoving( SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Returns true if ANY or ALL squads in an SGroup are moving. 
SGroup_IsOnScreen( PlayerID player, SGroupID group, Bool all, Float percent ) RETURNS: Bool =>Returns true if ANY or ALL (use those keywords) of the squads in the group are present onscreen. You can pass in a percentage of the screen to check, so 0.8 would be a centered rectangle occupying 80% of the screen. 
SGroup_IsPinned( SGroupID group, Boolean all ) RETURNS: Boolean =>Returns true if ANY or ALL of a group is pinned. 
SGroup_IsReinforcing( SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Returns true if ALL or ANY squads in a group are currently calling for reinforcments. 
SGroup_IsRetreating( SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Returns true if ANY or ALL of the squads in an SGroup are currently retreating. 
SGroup_IsSettingDemolitions( SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Returns true if ANY or ALL squads are setting demolitions. 
SGroup_IsSuppressed( SGroupID group, Boolean all ) RETURNS: Boolean =>Returns true is ANY or ALL of a group is suppressed. 
SGroup_IsUnderAttack( SGroupID sgroup, Boolean all, Float time ) RETURNS: Boolean =>Returns true if ALL or ANY squads are under attack within the time. 
SGroup_IsUnderAttackByPlayer( SGroupID group, PlayerID attackerplayer, Float duration ) RETURNS: Bool =>Check if the squads are attacked by the player. 
SGroup_IsUnderAttackFromDirection( SGroupID sgroup, Boolean all, Integer offset, Float time ) RETURNS: Boolean =>Returns true if ALL or ANY squads are under attack from a direction within the time. see ScarUtil.scar for types of directions. you can pass in a table of directions. 
SGroup_IsUpgrading( SGroupID sgroup, UpgradeBlueprint blueprint, Boolean all ) RETURNS: Boolean =>Returns true if ALL or ANY squads in a group are currently upgrading. You can pass in nil for upgradeid if it doesn't matter what is being upgraded. 
SGroup_IsUsingAbility( SGroupID sgroup, Boolean ALL ) RETURNS: Boolean =>Checks if ANY or ALL squads in an SGroup are using an ability. 
SGroup_Kill( SGroupID sgroup ) RETURNS: Void =>Kills all squads in an SGroup. This kills them 'naturally', as opposed to SGroup_DestroyAllSquads() which makes them blink out of existance. 
SGroup_Remove( SGroup * group, Squad * squadron ) RETURNS: void =>Removes an squadron from a group. 
SGroup_RemoveGroup( SGroupID group, SGroupID grouptoremove ) RETURNS: Void =>Remove from the first SGroup all squads contained in the second SGroup. SGroup2 remains untouched. 
SGroup_RemoveUpgrade( SGroupID sgroup, UpgradeBlueprint/Table upgrade ) RETURNS: Void =>Removes upgrade(s) from an sgroup. 
SGroup_ReSpawn( SGroupID groupid ) RETURNS: Void =>Respawn all despawned squads in a group. 
SGroup_RestoreCombatPlans( SGroupID sgroupID ) RETURNS: Void =>Restore all current combat plans for the squads in the sgroup. 
SGroup_RewardActionPoints( SGroupID sgroup, Float actionpoint ) RETURNS: Void =>Give action points to the squad. 
SGroup_SetAnimatorState( SGroupID sgroupid, String stateMachineName, String stateName ) RETURNS: Void =>Set animation state of a state machine for an SGroup. Please only use this for simple animations. 
SGroup_SetAutoTargetting( SGroupID group, String hardpoint, Bool enable ) RETURNS: Void =>Sets whether a weapon to auto-target things or not. 
SGroup_SetAvgHealth( SGroupID sgroup, Real healthpercent ) RETURNS: Real =>Sets the health of each squad in a squad group to a given percent [0.0, 1.0]. 
SGroup_SetAvgMorale( SGroup sgroup, Real moralepercent ) RETURNS: Real =>Sets the moral of each squad in a squad group to a given percent [0.0, 1.0]. 
SGroup_SetCrushable( SGroupID sgroup, Boolean crushable ) RETURNS: Void =>Overrides crushable behavior for an sgroup. 
SGroup_SetInvulnerable( SGroupID sgroup, Boolean/Real enabled, Float reset_time ) RETURNS: Void =>Enable/Disable invulnerablity for an entire SGroup. Use true and false for simple on/off, or use a number between 0.0 and 1.0 for more precise control on how much damage a squad can take before it takes no more. 
SGroup_SetInvulnerableToCritical( SGroupID sgroup, Boolean/Real enabled ) RETURNS: Void =>Enable/Disable invulnerablity to criticals for an entire SGroup. 
SGroup_SetMoodMode( SGroupID group, Integer mode ) RETURNS: Void =>Set soldier mood mode. Mode could be MM_Auto, MM_ForceCalm or MM_ForceTense. 
SGroup_SetPlayerOwner( SGroupID sgroup, PlayerID owner ) RETURNS: Void =>Changes the player owner of spawned and despawned squads in an SGroup. 
SGroup_SetRecrewable( SGroupID sgroup, Boolean recrewable ) RETURNS: Void =>Sets all squads in as sgroup to be recrewable or not when abandoned. 
SGroup_SetSelectable( SGroup sgroupid, bool selectable ) RETURNS: Void =>Set player selectable state of squads in the sgroup. 
SGroup_SetSharedProductionQueue( SGroupID egroup, Boolean enable ) RETURNS: Void =>Enables shared team production on a building (teammates can build using THEIR resources) 
SGroup_SetSuppression( SGroupID groupid, Float suppression ) RETURNS: Void =>Set the suppression level for all squads in the sgroup. 
SGroup_SetTeamWeaponCapturable( SGroupID group, Boolean enable ) RETURNS: Void =>Set team weapon in the squads to be capturable or not. 
SGroup_SetVeterancyDisplayVisibility( SGroupID groupid, bool visible ) RETURNS: Void =>Sets the visibility of in-game veterancy art for the squads in given SGroup. 
SGroup_SetWorldOwned( SGroupID sgroup ) RETURNS: Void =>Makes an sgroup neutral. 
SGroup_Single( SGroupID groupID, squadID squad ) RETURNS: SGroupID =>Creates a squad group containing a single squad. 
SGroup_SnapFaceEachOther( SGroupID sgroup1, SGroupID sgroup2 ) RETURNS: Void =>Makes two SGroups face each other at no time. 
SGroup_SnapFacePosition( SGroup * sgroup, ScarPosition pos ) RETURNS: void =>Works like SGroup_FacePosition except with no interpolation. All Squads will face the same direction, with the squad the closest to the center determining the direction. 
SGroup_TotalMembersCount( SGroupID sgroup, Bool dontCountTeamWeapons ) RETURNS: Integer =>Returns the total count of all members of all the squads in a given SGroup. 
SGroup_WarpToMarker( SGroupID sgroup, MarkerID marker ) RETURNS: Void =>Warps all members of an SGroup immediately to a marker. 
SGroup_WarpToPos( SGroupID sgroup, Position pos ) RETURNS: Void =>Warps all members of an SGroup immediately to a new position. 
ShootTheSky_AddSyncWeapon( SyncWeaponID syncweapon, PlayerID player ) RETURNS: Void =>Forces a sync weapon to shoot at the sky, so long as it's manned by a given player. 
ShootTheSky_RemoveAll( Void  ) RETURNS: Void =>Stops all sync weapons from going through their "shooting at the sky" routine. 
ShootTheSky_RemoveSyncWeapon( SyncWeaponID syncweapon ) RETURNS: Void =>Removes a sync weapon from the "shoot at the sky" system. It can then target people again. 
Sound_PlayOnSquad( String soundpathname, SGroupID/Squad sgroupid ) RETURNS: Integer =>Play sound on the first entity of the squad in sgroup. 
Squad_AddAbility( Squad * squad, ScarAbilityPBG ability ) RETURNS: void =>Allows the squad to use this ability. 
Squad_AddSlotItemToDropOnDeath( Squad * squad, ScarSlotItemPBG pbg, float dropChance, bool exclusive ) RETURNS: void =>Add to the list of slot items to drop when this squad is wiped out. 
Squad_CanCaptureStrategicPoint( Squad * squad, Entity * entity ) RETURNS: bool =>Returns true if squad can capture stategic point. 
Squad_CanCaptureTeamWeapon( Squad * pSquad, Entity * pEntity ) RETURNS: bool =>True if the squad can capture the entity sync weapon. 
Squad_CanCastAbilityOnEGroup( SquadID caster, AbilityBlueprint ability, EGroup target_egroup ) RETURNS: Void =>Test whether a squad can be ordered to do this ability on any member of the target EGroup. 
Squad_CanCastAbilityOnEntity( Squad * castingSquad, ScarAbilityPBG abilityPBG, Entity * targetEntity ) RETURNS: bool =>Test whether a squad can be ordered to do this ability on the target squad. 
Squad_CanCastAbilityOnPosition( Squad * castingSquad, ScarAbilityPBG abilityPBG, ScarPosition targetPos ) RETURNS: bool =>Test whether a squad can be ordered to do this ability on the target squad. 
Squad_CanCastAbilityOnSGroup( SquadID caster, AbilityBlueprint ability, SGroup target_sgroup ) RETURNS: Void =>Test whether a squad can be ordered to do this ability on any member of the target SGroup. 
Squad_CanCastAbilityOnSquad( Squad * castingSquad, ScarAbilityPBG abilityPBG, Squad * targetSquad ) RETURNS: bool =>Test whether a squad can be ordered to do this ability on the target squad. 
Squad_CancelProductionQueueItem( Squad * squad, uint32_t index ) RETURNS: void =>Cancels an item in a production queue. Index 0 is the currently producing item. 
Squad_CanHold( Squad * squad ) RETURNS: bool =>Checks whether a squad can hold any squad. 
Squad_CanInstantReinforceNow( Squad * squad ) RETURNS: bool =>Returns true if the squad is available to be reinforced. 
Squad_CanLoadSquad( Squad * squad, Squad * loadthis, bool bCheckSquadState, bool bOverload ) RETURNS: bool =>Checks whether a squad can load another squad. 
Squad_CanPickupSlotItem( Squad * pSquad, Entity * pEntity ) RETURNS: bool =>True if the squad can pickup the entity slot item. 
Squad_CanRecrew( Squad * pSquad, Entity * pEntity ) RETURNS: bool =>True if the squad can recrew the entity. 
Squad_CanSeeEntity( Squad * squad, Entity * entity ) RETURNS: bool =>Returns true if the distance between a target entity and the source squad is less than it squad's sight distance. There is no LOS or FOW check. 
Squad_CanSeeSquad( Squad * squad, Squad * target ) RETURNS: bool =>Returns true if the distance between a target squad and the source squad is less than it squad's sight distance. There is no LOS or FOW check. 
Squad_ClearPostureSuggestion( Squad * squad ) RETURNS: void =>Clears any previous posture suggestions made to a squad. 
Squad_CompleteUpgrade( Squad * pSquad, ScarUpgradePBG upgradePBG ) RETURNS: void =>Instantly adds an upgrade to a given squad. 
Squad_Count( Squad * squad ) RETURNS: int =>Returns the number of units currently in a squad (spawned AND despawned!!) 
Squad_CreateAndSpawnToward( ScarSquadPBG sbp, Player * player, size_t loadoutCount, ScarPosition pos, ScarPosition toward ) RETURNS: Squad * =>Create a squad, spawn it and assign it to a player. 
Squad_DeSpawn( Squad * squad ) RETURNS: void =>Despawn the entire squad at its current position. 
Squad_Destroy( Squad * squad ) RETURNS: void =>Remove an squad from the world and destroy it. 
Squad_EnableProductionQueue( Squad * squad, bool enable ) RETURNS: void =>Sets whether a squad can produce anything (including upgrades) 
Squad_EnableSurprise( Squad * squad, bool enable ) RETURNS: void =>Enables or disables the surprise feature on thie given squad. 
Squad_EntityAt( Squad * squad, uint32_t index ) RETURNS: Entity * =>ZERO-BASED get of entities out of squads. 
Squad_FacePosition( Squad * squad, ScarPosition pos ) RETURNS: void =>Set the rotation of all troopers in a squad to face the position. 
Squad_FaceSquad( Squad * squad1, Squad * squad2 ) RETURNS: void =>Get 2 squads to face each other. This function works on spawned squads only. 
Squad_FindCover( Squad * squad, ScarPosition pos, float coverSearchRadius ) RETURNS: ScarPosition =>Tries to find cover within a certain radius of a position. If no cover is found, it returns the position used for the search. 
Squad_FindCoverCompareCurrent( Squad * squad, ScarPosition pos, float coverSearchRadius, float maxPathDistanceFromGoal, bool compareToCurrentCover ) RETURNS: ScarPosition =>Tries to find cover within a certain radius of a position, traveling a max distance to get there, and possibly comparing against current position's cover. If no cover is found, it returns the position used for the search. 
Squad_FromWorldID( uint32_t id ) RETURNS: Squad * =>Get a squad from a mission editor ID. 
Squad_GetActiveCommand( Squad * squad ) RETURNS: SquadStateID =>Returns the active squad command. 
Squad_GetAttackPlan( Squad * squad ) RETURNS: const char * =>Get name of current Squad AI attack plan. 
Squad_GetAttackTargets( Squad * squad, SGroup * group ) RETURNS: void =>Find the squad member current or forced targets. If found, the targets squads are added to the sgroup. Entity targets like buildings are ignored. 
Squad_GetBlueprint( Squad * squad ) RETURNS: ScarSquadPBG =>Returns the name of the squad blueprint (from the attribute editor) 
Squad_GetCoverLevel( Squad * pSquad ) RETURNS: int =>Returns a number representing how good squad cover is -1 for awful, 0 for none, 1 for light, 2 for heavy. 
Squad_GetDestination( Squad * squad ) RETURNS: ScarPosition =>Returns the squad's destination, if it's moving. IMPORTANT: you must only call this function if Squad_HasDestination has returned true. 
Squad_GetGameID( Squad * squad ) RETURNS: uint32_t =>Returns an integer containing the unqiue squad ID for this squad. 
Squad_GetHeading( Squad * squad ) RETURNS: ScarPosition =>Returns the average heading of the spawned units in the squad. The heading is currently a lua table with three entries (x, y, z) 
Squad_GetHealth( Squad * squad ) RETURNS: float =>Returns the current health of a squad. 
Squad_GetHealthMax( Squad * squad ) RETURNS: float =>Returns the max health of the squad. 
Squad_GetHealthPercentage( Squad * squad ) RETURNS: float =>Returns how much of an original squad's health is left, accounting for deaths (ex: a squad of 3 riflemen would be at 50% health, since they started with 6 members) Note: This is the same percentage that the UI uses. 
Squad_GetHoldEntity( Squad * squad ) RETURNS: Entity * =>Get which building (entity) is the squad garrisoned. 
Squad_GetHoldSquad( Squad * squad ) RETURNS: Squad * =>Get which vehicle (squad) is the squad garrisoned. 
Squad_GetInvulnerable( SquadID squad ) RETURNS: Bool =>Check if the squad is invulnerable or not. 
Squad_GetInvulnerableEntityCount( Squad * squad ) RETURNS: int =>Returns the number of invulnerable member. 
Squad_GetInvulnerableMinCap( Squad * squad ) RETURNS: float =>Returns the highest invulnerable min cap percentage from members of the squad. 
Squad_GetLastAttacker( Squad * squad, SGroup * group ) RETURNS: void =>Find the last squad attacker on this squad. If found, the squad is added to the sgroup. 
Squad_GetLastAttackers( Squad * squad, SGroup * group, float timeSeconds ) RETURNS: void =>Find the squad attackers on this squad from the last seconds specified. If found, the squads are added to the sgroup. Building attackers are ignored. 
Squad_GetLastEntityAttacker( Squad * pSquad, EGroup * pEGroup ) RETURNS: void =>Find the last entity attacker on this squad. If found, the entity added to egroup. 
Squad_GetMax( Squad * squad ) RETURNS: int =>Returns the max number of units allowed in the squad. 
Squad_GetMinArmor( Squad * squad ) RETURNS: float =>Returns the current minimum armor of a squad. 
Squad_GetNumSlotItem( Squad * squad, ScarSlotItemPBG pbg ) RETURNS: size_t =>Get the number of slot items with the same ID that the squad has. 
Squad_GetOffsetPosition( SquadID squad, Integer offset, Real distance ) RETURNS: Position =>Returns a position relative to a squad's current position and orientation. see ScarUtil.scar for explanation of 'offset' parameter. 
Squad_GetPinnedPlan( Squad * squad ) RETURNS: const char * =>Get name of current Squad AI reaction plan. 
Squad_GetPlayerOwner( Squad * squad ) RETURNS: Player * =>Returns the Player owner of the given squad. Squad MUST NOT be owned by the world. 
Squad_GetPosition( Squad * squad ) RETURNS: ScarPosition =>Returns the average position of the spawned units in the squad. The position is currently a lua table with three entries (x, y, z) 
Squad_GetPositionDeSpawned( Squad * squad ) RETURNS: ScarPosition =>Returns the average position of the despawned AND spawned units in the squad. 
Squad_GetProductionQueueItem( Squad * squad, size_t index ) RETURNS: const PropertyBagGroup * =>Returns the blueprint for a production queue item with index. 
Squad_GetProductionQueueItemType( Squad * squad, size_t index ) RETURNS: int =>Returns the production type (PITEM_Upgrade, PITEM_Spawn, PITEM_SquadUpgrade, PITEM_SquadReinforce, PITEM_PlayerUpgrade) for a production queue item with index. 
Squad_GetProductionQueueSize( Squad * squad ) RETURNS: size_t =>Returns the number of items in the squad's production queue. 
Squad_GetReactionPlan( Squad * squad ) RETURNS: const char * =>Get name of current Squad AI reaction plan. 
Squad_GetRetaliationPlan( Squad * squad ) RETURNS: const char * =>Get name of current Squad AI retaliation plan. 
Squad_GetSlotItemAt( Squad * squad, size_t index ) RETURNS: ScarSlotItemPBG =>Returns the ID of the slot item. Use Squad_GetSlotItemCount to determine how many slot items the squad has. The first index is 1. 
Squad_GetSlotItemCount( Squad * squad ) RETURNS: size_t =>Returns how many slot items this squad has. 
Squad_GetSlotItemsTable( SquadID squadid ) RETURNS: LuaTable =>Returns a table of SlotItem ID's that this squad currently owns. 
Squad_GetSquadsHeld( Squad * squad, SGroup * sgroup ) RETURNS: bool =>Adds all squads held by 'squad' to an sgroup. 
Squad_GetSuppression( Squad * squad ) RETURNS: float =>Check current squad suppresion level. Return value from 0 to 1. 
Squad_GetVehicleMobileDriverSquad( Squad * pSquad ) RETURNS: Squad * =>Gets the mobile driver squad from a vehicle squad. 
Squad_GetVeterancyExperience( Squad * squad ) RETURNS: float =>Get current squad veterancy experience. 
Squad_GetVeterancyRank( Squad * squad ) RETURNS: size_t =>Get current squad veterancy rank. 
Squad_GiveSlotItem( Squad * squad, ScarSlotItemPBG pbg ) RETURNS: void =>Gives a slot item to the squad. Can fail due to not enough slots left. 
Squad_GiveSlotItemsFromTable( SquadID squadid, LuaTable itemTable ) RETURNS: Void =>Gives all slot items in a table to the squad. The table should come from Squad_GetSlotItemsTable. 
Squad_HasActiveCommand( Squad * squad ) RETURNS: bool =>Returns true if there's an active command currently for the squad. 
Squad_HasAnyCritical( Squad * squad ) RETURNS: bool =>Return true if any entity in the squad has any critical applied to it. 
Squad_HasCritical( SquadID squad, CriticalID critical ) RETURNS: Bool =>Check if a squad has a critical or not. 
Squad_HasDestination( Squad * squad ) RETURNS: bool =>Returns whether this squad is moving and has a destination. 
Squad_HasProductionQueue( Squad * squad ) RETURNS: bool =>Returns true if a squad has a production queue. 
Squad_HasSetupWeapon( Squad * pSquad ) RETURNS: bool =>Returns true if the given squad has a setup weapon. 
Squad_HasSlotItem( SquadID squad, SlotItemID slotItem ) RETURNS: Bool =>Check if a squad has a specific slot item. 
Squad_HasSoldier( Squad * pSquad ) RETURNS: bool =>Returns true if the given squad has soldiers in it (includes team weapons) 
Squad_HasTeamWeapon( Squad * pSquad ) RETURNS: bool =>Returns true if the given squad has a team weapon. 
Squad_HasUpgrade( Squad * squad, ScarUpgradePBG pbg ) RETURNS: bool =>Return true if the squad has purchased the specified upgrade. 
Squad_HasVehicle( Squad * pSquad ) RETURNS: bool =>Returns true if the given squad has a vehicle in it (includes team weapons) 
Squad_IncreaseVeterancyExperience( Squad * squad, float experience, bool silent, bool applyModifiers ) RETURNS: void =>Increase current squad veterancy experience. 
Squad_IncreaseVeterancyRank( Squad * squad, int numranks, bool silent ) RETURNS: void =>Increase current squad veterancy rank. 
Squad_InstantSetupTeamWeapon( Squad * squad ) RETURNS: void =>Stops current squads activity and instant setup the team weapon if they have one. 
Squad_IsAttacking( Squad * squad, float time ) RETURNS: bool =>Returns true if any unit in the squad is attacking within the time. 
Squad_IsCamouflaged( SquadID squad ) RETURNS: Boolean =>Returns whether ANY entity in the squad is camouflaged. 
Squad_IsDoingAbility( Squad * squad, ScarAbilityPBG pbg ) RETURNS: bool =>True if squad is currently performing the given ability. 
Squad_IsFemale( Squad * squad ) RETURNS: bool =>Returns whether the passed in squad is female. 
Squad_IsHoldingAny( Squad * squad ) RETURNS: bool =>Check if the squad has a hold on anything (use this on vehicles) 
Squad_IsInCover( SquadID squadId, Boolean all ) RETURNS: Boolean =>Returns true if ALL or ANY troopers in a squad are in cover. 
Squad_IsInHoldEntity( Squad * squad ) RETURNS: bool =>Check if the squad is garrisoned in entity (building) 
Squad_IsInHoldSquad( Squad * squad ) RETURNS: bool =>Check if the squad is loaded in squad (vehicle. 
Squad_IsMoving( Squad * squad ) RETURNS: bool =>Returns whether any entity in the squad is moving. 
Squad_IsPinned( Squad * squad ) RETURNS: bool =>True if squad is currently pinned. 
Squad_IsPinnedOrSuppressed( Squad * squad ) RETURNS: bool =>True if squad is currently pinned or suppressed. 
Squad_IsReinforcing( Squad * squad ) RETURNS: bool =>Returns true if the squad is currently reinforcing. This function will return false if the squad does not have a reinforce ext. 
Squad_IsRetreating( SquadID squadid ) RETURNS: Boolean =>Returns true if the squad is currently retreating. 
Squad_IsSuppressed( Squad * squad ) RETURNS: bool =>True if squad is currently suppressed. 
Squad_IsUnderAttack( Squad * squad, float time ) RETURNS: bool =>Returns true if any unit in the squad is under attack within the time. 
Squad_IsUnderAttackByPlayer( Squad * squad, Player * pAttackerOwner, float time ) RETURNS: bool =>Returns true if squad is under attack by enemy from a particular player. 
Squad_IsUnderAttackFromDirection( Squad * squad, int offset, float timeSeconds ) RETURNS: bool =>Returns true if the squad was under attack from a certain direction (8 offset types, see ScarUtil.scar) 
Squad_IsUpgrading( Squad * squad, ScarUpgradePBG upgrade ) RETURNS: bool =>Returns true if the squad is currently upgrading something specific. 
Squad_IsUpgradingAny( Squad * squad ) RETURNS: bool =>Returns true if the squad is currently upgrading anything. 
Squad_IsValid( uint32_t id ) RETURNS: bool =>Check if a squad with the given ID can be found in the world. 
Squad_Kill( Squad * squad ) RETURNS: void =>Kill whole squad. Sets health to 0, and triggers death effects. 
Squad_Population( Squad * squad, CapType type ) RETURNS: float =>get squad pop cost, use CT_Personnel, CT_Vehicle, CT_Medic for captype 
Squad_RemoveAbility( Squad * squad, ScarAbilityPBG ability ) RETURNS: void =>Removes an ability that was previously added by Squad_AddAbility. You cannot remove static abilities (from AE: squad_ability_ext) 
Squad_RemoveSlotItemAt( Squad * squad, size_t index, bool bInstantWeaponChange ) RETURNS: void =>Removes a slot item from the squad. 
Squad_RemoveUpgrade( Squad * squad, ScarUpgradePBG upgrade ) RETURNS: void =>Removes an upgrade from a squad. 
Squad_RewardActionPoints( Squad * squad, float actionPoint ) RETURNS: void =>Give squad action points. 
Squad_SBPEntityAt( ScarSquadPBG sbp, uint32_t index ) RETURNS: ScarEntityPBG =>ZERO-BASED get of entity blueprints out of squad blueprint. 
Squad_SBPGetMax( ScarSquadPBG sbp ) RETURNS: int =>Returns the max number of units allowed in the squad blueprint. 
Squad_SetAnimatorState( SquadID squadid, String stateMachineName, String stateName ) RETURNS: Void =>Set animation state of a state machine for a squad Please only use this for simple animations. 
Squad_SetAttackPlan( Squad * squad, const char * planName ) RETURNS: void =>Set overriding Squad AI attack plan. 
Squad_SetHealth( Squad * squad, float healthPercent ) RETURNS: void =>Set the health of all units in a squad. Health must be in range [0.0, 1.0]. 
Squad_SetInvulnerable( SquadID squad, Bool enable, Float reset_time ) RETURNS: Void =>Set invulnerability on the squad. Reset time is in seconds. If it it set, the invulnerability will expire after this time. 
Squad_SetInvulnerableEntityCount( Squad * squad, int invEntityCount, float resetTime ) RETURNS: void =>Make a squad invulnerable to physical damage when number of members drop to or below specified count. 
Squad_SetInvulnerableMinCap( Squad * squad, float minHealthPercentage, float resetTime ) RETURNS: void =>Make a squad invulnerable to physical damage. 
Squad_SetInvulnerableToCritical( Squad * squad, bool invulnerable ) RETURNS: void =>set invulnerability to critical effect for all entities in the entire squad. Invulnerable to critical also means that kills a entity will not have effect 
Squad_SetMoodMode( Squad * squad, SquadCombatBehaviourExt::MoodMode mood ) RETURNS: void =>Set soldier mood mode. 
Squad_SetMoveType( Squad * squad, ScarMoveTypePBG movetypePBG ) RETURNS: void =>Sets the squad's move type. 
Squad_SetPinnedPlan( Squad * squad, const char * planName ) RETURNS: void =>Set overriding Squad AI pinned plan. 
Squad_SetPlayerOwner( Squad * squad, Player * owner ) RETURNS: void =>Changes the owner of the given squad. 
Squad_SetPosition( Squad * squad, ScarPosition pos, ScarPosition toward ) RETURNS: void =>Moves the squad to an arbitrary new position. 
Squad_SetReactionPlan( Squad * squad, const char * planName ) RETURNS: void =>Set overriding Squad AI reaction plan. 
Squad_SetRecrewable( Squad * squad, bool capturable ) RETURNS: void =>Set entity inside the squad to be recrewable or not when it becomes abandoned. 
Squad_SetRetaliationPlan( Squad * squad, const char * planName ) RETURNS: void =>Set overriding Squad AI idle retaliation plan. 
Squad_SetSharedProductionQueue( Squad * squad, bool shared ) RETURNS: void =>Enables shared team production on a building (teammates can build using THEIR resources) 
Squad_SetSuppression( Squad * squad, float percentage ) RETURNS: void =>Set current squad suppresion level. Suppression value value from 0 to 1. 
Squad_SetVeterancyDisplayVisibility( Squad * squad, bool visible ) RETURNS: void =>Turn on/off display of the unit portrait veterancy stars. 
Squad_SetWorldOwned( Squad * squad ) RETURNS: void =>Makes a squad neutral. 
Squad_Spawn( Squad * squad, ScarPosition pos ) RETURNS: bool =>Spawn the entire squad at a given position. 
Squad_SpawnToward( Squad * squad, ScarPosition pos, ScarPosition toward ) RETURNS: bool =>Spawn the entire squad at a given position. 
Squad_Split( Squad * squad, unsigned int num ) RETURNS: Squad * =>Split the squad into 2. The new squad size is specified by the number passed in. 
Squad_StopAbility( Squad * squad, ScarAbilityPBG ability, bool bEarlyExit ) RETURNS: void =>Abruptly stops an active ability. 
Squad_WarpToPos( SquadID squad, Position pos ) RETURNS: Void =>Warps a squad immediately to a new position. 
SquadQuery_CanCauseSuppression( AIPlayer * aiPlayer, Squad * pSquad ) RETURNS: bool =>Checks if this squad can cause suppression. 
SquadQuery_CanDecrew( Squad * pDriverSquad, Entity * pDecrewTargetEntity ) RETURNS: bool =>Checks if this squad can decrew the entity. 
SquadQuery_GetAnySquadCombatTarget( Squad * pSquad ) RETURNS: Squad * =>Returns the current squad target for the given squad (null if no target, or target is non-squad entity) 
Stats_BuildingsLost( const ModPlayer * player ) RETURNS: int =>Returns how many buildings a player has lost. 
Stats_InfantryLost( const ModPlayer * player ) RETURNS: int =>Returns how many infantry a player has lost. 
Stats_KillsTotal( const ModPlayer * player ) RETURNS: int =>Returns a player's total kills. 
Stats_PlayerAt( size_t index ) RETURNS: uint32_t =>Returns player id at given index. 
Stats_PlayerCount(  ) RETURNS: size_t =>Returns how many players in the game. 
Stats_ResGathered( const ModPlayer * player ) RETURNS: ResourceAmount =>Returns how many resources a player has gathered. 
Stats_ResSpent( const ModPlayer * player ) RETURNS: ResourceAmount =>Returns how many resources a player has spent. 
Stats_SoldiersKilled( const ModPlayer * player ) RETURNS: int =>Returns how many soldiers a player has killed. 
Stats_StructuresKilled( const ModPlayer * player ) RETURNS: int =>Returns how many structures a player has killed. 
Stats_TeamTally( Integer teamindex, Function statfunction ) RETURNS: Integer =>Takes a statistic function and totals up the results for all the players on a given team. 
Stats_TotalDuration(  ) RETURNS: int =>Returns game time, in seconds. 
Stats_TotalSquadsLost( const ModPlayer * player ) RETURNS: int =>Returns how many squads a playe has lost. 
Stats_UnitSoldierKills( const ModPlayer * player, ScarSquadPBG sbp ) RETURNS: int =>Returns how many soldiers an SBP have killed. ex: how many soldiers did player2's riflemen kill? 
Stats_UnitStructureKills( const ModPlayer * player, ScarSquadPBG sbp ) RETURNS: int =>Returns how many structures an SBP have killed. ex: how many structures did player2's riflemen kill? 
Stats_UnitTotalKills( const ModPlayer * player, ScarSquadPBG sbp ) RETURNS: int =>Returns how many entities an SBP have killed. ex: how many entities did player2's riflemen kill? 
Stats_UnitVehicleKills( const ModPlayer * player, ScarSquadPBG sbp ) RETURNS: int =>Returns how many vehicles an SBP have killed. ex: how many vehicles did player2's riflemen kill? 
Stats_VehiclesKilled( const ModPlayer * player ) RETURNS: int =>Returns how many vehicles a playe has killed. 
Stats_VehiclesLost( const ModPlayer * player ) RETURNS: int =>Returns how many vehicles a player has lost. 
Table_Contains( LuaTable OriginalTable, Item item ) RETURNS: Boolean =>Checks if a table contains the specified item. 
Table_Copy( LuaTable OriginalTable ) RETURNS: LuaTable =>Copies the contents of the original table returns a new table with the contents of that table. 
Table_GetRandomItem( Table table, Integer numberofitems ) RETURNS: Item Table =>Returns a random item from a table. You can return multiple items (without duplicates) by passing in an optional number parameter. 
Team_AddResource( TeamID team, Integer resourceType, Real value ) RETURNS: Void =>Add resource to each member of a team, as opposed to just setting it. Possible resource types are RT_Manpower, RT_Munition, RT_Fuel, RT_Action. 
Team_AddSquadsToSGroup( TeamID team, String squadgroupName ) RETURNS: SGroupID =>For the given team, get all of the squads gathered into a squadgroup of your naming. 
Team_AreSquadsNearMarker( TeamID team, MarkerID marker ) RETURNS: Boolean =>Returns true if ANY of a teams squads are in proximity of a marker. 
Team_CanSee( TeamID teamid, EGroupID/SGroupID/EntityID/SquadId/PositionID/MarkerID item, Boolean all ) RETURNS: Boolean =>Returns true if a team can see ALL or ANY items. 
Team_ClearArea( TeamID team, MarkerID marker, Bool invulnerable ) RETURNS: Void =>Any of the team's units in the marker area move out of the area, and can be made invulnerable for a bit whilst they do it. 
Team_FindByRace( String race, String race2, ...  ) RETURNS: TeamID =>Returns the TeamID for a given race. See ScarUtil.scar for constants to use. 
Team_ForEachAllOrAny( TeamID team, Boolean all, LuaFunction function ) RETURNS: Boolean =>Tests a condition on teams. Calls your function for each player. Parameters of your function: (TeamID, player index, PlayerID). Your function must return true or false to indicate whether the player meets the condition. 
Team_GetAll( TeamID team, SGroupID sgroup, EGroupID egroup ) RETURNS: Void =>Creates/Clears groups that contain all of a team's units and buildings. Defaults - sg_allsquads and eg_allentities. 
Team_GetAllEntitiesNearMarker( TeamID team, EGroupID egroup, MarkerID/Pos/SectorID position, Real range ) RETURNS: Void =>Gather together all of a teams's entities that are in proximity to a marker, a position, or within a territory sector into an EGroup. The EGroup is cleared beforehand. 
Team_GetAllSquadsNearMarker( TeamID team, SGroupID sgroup, MarkerID/Pos/SectorID position, Real range ) RETURNS: Void =>Gather together all of a teams's squads that are in proximity to a marker, a position, or within a territory sector into an SGroup. The SGroup is cleared beforehand. 
Team_GetBuildingID( PlayerID player, BlueprintTable entitytypes, ANY bool ) RETURNS: EntityID Table =>Returns the entityID of the first team owned building listed in the table. 
Team_GetBuildingsCount( TeamID team ) RETURNS: Integer =>Returns the total number of buildings owned by this team. 
Team_GetBuildingsCountExcept( TeamID team, BlueprintTable exceptions ) RETURNS: Integer =>Returns the total number of buildings owned by this team (with exclusions). 
Team_GetBuildingsCountOnly( TeamID team, BlueprintTable ebplist ) RETURNS: Integer =>Returns the number of buildings owned by this team (inclusive). 
Team_GetEnemyTeam( TeamID team ) RETURNS: TeamID =>Returns a team's enemy. 
Team_GetEntitiesFromType( TeamID team, String unitType ) RETURNS: EGroup =>Returns an EGroup containing all of the teams entities of a specific unit_type (as defined by the type_ext on the entity) 
Team_GetEntityConcentration( TeamID team, Boolean popcapOnly, Table includeBlueprints, Table excludeBlueprints, Boolean bLeastConcentrated, MarkerID/Table onlyInThisMarker ) RETURNS: EGroup =>Finds the greatest (or least) concentration of entities owned by a team. 
Team_GetSquadConcentration( TeamID team, Boolean popcapOnly, Table includeBlueprints, Table excludeBlueprints, Boolean bLeastConcentrated, MarkerID/Table onlyInThisMarker ) RETURNS: SGroup =>Finds the greatest (or least) concentration of squads owned by a team. 
Team_HasBuilding( TeamID team, BlueprintTable entitytypes, ANY bool ) RETURNS: boolean =>Returns true if this team owns any buildings listed in the table. 
Team_HasBuildingsExcept( TeamID team, BlueprintTable exceptions, ANY bool ) RETURNS: boolean =>Returns true if this team owns any buildings. (with exclusions). 
Team_HasBuildingUnderConstruction( TeamID team, BlueprintTable entitytypes, ANY bool ) RETURNS: boolean =>Returns true if this team owns any buildings listed in the table currently under construction. 
Team_HasHuman( TeamID team, ANY bool ) RETURNS: boolean =>Returns true if this team has any players that are human. 
Team_IsAlive( UnknownType teamid ) RETURNS: Boolean =>Returns whether a team is still alive or not (all member players must be 'alive')  TeamID team. 
Team_OwnsEGroup( TeamID team, EGroupID egroup, Boolean any ) RETURNS: Boolean =>Returns true if a given team owns ALL or ANY items in a group. 
Team_OwnsEntity( TeamID team, EntityID entity ) RETURNS: Boolean =>Returns true if a given team owns an entity. 
Team_OwnsSGroup( TeamID team, SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Returns true if a given team owns ALL or ANY items in a group. 
Team_OwnsSquad( TeamID team, SquadID squad ) RETURNS: Boolean =>Returns true if a given team owns a squad. 
Team_RestrictAddOnList( TeamID team, Table addonlist ) RETURNS: Void =>Restrict a list of addons. 
Team_RestrictBuildingList( TeamID team, Table blueprintlist ) RETURNS: Void =>Restrict a list of buildings. 
Team_RestrictResearchList( TeamID team, StringTable list ) RETURNS: Void =>Restrict a list of research items. 
Team_SetAbilityAvailability( TeamID team, AbilityBlueprint/Table bp, Integer availability ) RETURNS: Void =>Sets the availability of an ability. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT. 
Team_SetCommandAvailability( TeamID team, Integer/Table command, Integer availability ) RETURNS: Void =>Sets the availability of entity, squad and player commands. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT. 
Team_SetConstructionMenuAvailability( TeamID team, String/Table menuname, Integer availability ) RETURNS: Void =>Sets the availability of a construction menu. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT. 
Team_SetEntityProductionAvailability( TeamID team, EntityBlueprint/Table bp, Integer availability ) RETURNS: Void =>Sets the availability of an entity production item. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT. 
Team_SetMaxCapPopulation( TeamID team, Integer captype, Integer newcap ) RETURNS: Void =>Sets the current personnel or vehicle max-cap for each player on a team. The captype is either CT_Personnel or CT_Vehicle (you can't adjust Medic caps just yet). 
Team_SetMaxPopulation( TeamID team, Integer captype, Integer newcap ) RETURNS: Void =>Sets the current personnel or vehicle cap for each player on a team. The captype is either CT_Personnel or CT_Vehicle (you can't adjust Medic caps just yet). 
Team_SetSquadProductionAvailability( TeamID team, SquadBlueprint/Table bp, Integer availability ) RETURNS: Void =>Sets the availability of a squad production item. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT. 
Team_SetTechTreeByYear( TeamID team, Integer year ) RETURNS: void =>Sets up the tech tree for a whole team based off the year. 
Team_SetUpgradeAvailability( TeamID team, UpgradeBlueprint/Table bp, Integer availability ) RETURNS: Void =>Sets the availability of an upgrade. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT. 
Team_SetUpgradeCost( TeamID team, UpgradeID upgrade, Real manpower, Real fuel, Real munition, Real action, Real command ) RETURNS: Void =>Sets the cost of an upgrade. 
TeamWeapon_AddGroup( SGroupID/EGroupID group, Table facingdirections, Integer currentfacing, Boolean threatarrow, Integer turnTime, Integer totalResponses ) RETURNS: Void =>Add a gun to the gun manager. The manager will take care of turning it around to attack units. Turntime is how often the weapon can turn (default 10 seconds), Total Responses is how many times he will adjust before stopping. 
TeamWeapon_RemoveDirections( SGroupID/EGroupID/SyncWeaponID gun ) RETURNS: Void =>Remove's the direction settings for a gun, turning it into a fire-at-anything type. 
TeamWeapon_RemoveGroup( SGroupID/EGroupID/SyncWeaponID gun ) RETURNS: Void =>Remove a gun from the gun manager. 
ThreatArrow_Add( Integer GroupID, entity/squad/egroup/sgroup/position/marker Threat, String icon ) RETURNS: Void =>Adds a threat to an existing group. 
ThreatArrow_CreateGroup( variable argument list:threats  ) RETURNS: Integer =>Creates a group of threats that are represented by a single arrow. Threats can be entities, squads, egroups, sgroups, positions or markers. 
ThreatArrow_DestroyAllGroups( UnknownType  ) RETURNS: Void =>Destroy all threat groups. 
ThreatArrow_DestroyGroup( Integer GroupID ) RETURNS: Void =>Destroy a threat group. 
ThreatArrow_Remove( Integer GroupID, entity/squad/egroup/sgroup/position/marker Threat ) RETURNS: Void =>Removes a threat from an existing group. 
Timer_Add( Integer timerID, Real period ) RETURNS: Void =>Add the amount of time to the specified timer. 
Timer_Advance( Integer timerID, Real period ) RETURNS: Void =>Advances the timer by the specified amount of time. 
Timer_Display( Integer timerID ) RETURNS: Void =>Display (in the console) the amount of time remaining in the specified timer. 
Timer_DisplayOnScreen( Integer timerID ) RETURNS: Void =>Displays a timer on the screen - You need to call this regularly (i.e. every second) to update the onscreen display. THIS IS A TEMPORARY FUNCTION - WELL GET PROPER UI SUPPORT LATER ON. 
Timer_End( Integer timerID ) RETURNS: Void =>Stop the specified timer. 
Timer_Exists( Integer timerID ) RETURNS: Boolean =>Returns whether the timer with this ID exists. 
Timer_GetElapsed( Integer timerID ) RETURNS: Real =>Returns how much time has elapsed since this timer has been started. 
Timer_GetMinutesAndSeconds( Luafunction getTimeFunction, Integer TimerID ) RETURNS: s =>Returns TWO values: minutes and seconds. Provide it a function like Timer_GetRemaining or Timer_GetElapsed. 
Timer_GetRemaining( Integer timerID ) RETURNS: Real =>Get the remaining time for the specified timer. 
Timer_IsPaused( Integer timerID ) RETURNS: Boolean =>Check if the timer is paused. 
Timer_Pause( Integer timerID ) RETURNS: Void =>Pause the specified timer. 
Timer_Resume( Integer timerID ) RETURNS: Void =>Resume the specified timer. 
Timer_Start( Integer timerID, Real period ) RETURNS: Void =>Start a timer with the specified id, taking the required period ( in seconds ) 
TimeRule_Add( LuaConfig::RefFunction f, int priority ) RETURNS: void =>Add a rule to be executed every frame. 
TimeRule_AddInterval( LuaConfig::RefFunction f, float interval, int priority ) RETURNS: void =>Add a rule to be executed at every 'interval' seconds. 
TimeRule_AddIntervalEx( LuaConfig::RefFunction f, float delay, float interval, int calls, int priority ) RETURNS: void =>Add a rule to be executed 'calls' times, at every 'interval' seconds. 
TimeRule_AddOneShot( LuaConfig::RefFunction f, float interval, int priority ) RETURNS: void =>Add a rule to be executed once, after 'interval' seconds. 
TimeRule_ChangeInterval( LuaConfig::RefFunction f, float interval ) RETURNS: void =>Change 'interval' seconds of an existing rule. 
TimeRule_Exists( LuaConfig::RefFunction f ) RETURNS: bool =>Test if a rule is currently active. 
TimeRule_Remove( LuaConfig::RefFunction f ) RETURNS: void =>Remove a currently active rule. 
TimeRule_RemoveAll( int maxpriority ) RETURNS: void =>Kills all rules. 
TimeRule_RemoveMe(  ) RETURNS: void =>Remove a currently executing rule (only works inside a rule function) 
TimeRule_Replace( LuaConfig::RefFunction oldf, LuaConfig::RefFunction newf ) RETURNS: void =>the old reference function with a new one 
ToW_SetStandardResources( PlayerID player, Table overrideData ) RETURNS: Void =>Set a player to have standard starting resources, or use optional override data. 
ToW_SetUpTechTreeByYear( PlayerID player, Int year ) RETURNS: Void =>Restricts a given player's tech tree to just the units that were available in a specific year. 
UI_AddHintAndFlashAbility( PlayerID playerid, AbilityID abilityID, LocString text, Integer length, Table/Blueprint blueprint_filter ) RETURNS: Void =>Creates and flashes an ability button on the taskbar if the unit is selected. 
UI_CreateEventCue( String iconPath, String soundPath, LocString title, LocString description, Float lifetime, Boolean dismissOnClick ) RETURNS: ID =>Creates an event cue without a callback (you won't know when it's clicked) 
UI_CreateMinimapBlip( StackVar where, Real lifetime, Integer blipType ) RETURNS: blipID =>Creates a blip on the minimap; return the ID of the blip. 
UI_CreateSGroupKickerMessage( PlayerID player, SGroup sgroup, LocString message ) RETURNS: Void =>Create a custom kicker message on the squad and display to the player. 
UI_DeleteMinimapBlip( Integer blipID ) RETURNS: Void =>Removes a blip already created on the minimap. 
UI_EnableEntityDecorator( Entity * entity, bool enabled ) RETURNS: void =>Turn on or off entity decorator. The default is decorator enabled. 
UI_EnableEntityMinimapIndicator( Entity * entity, bool enabled ) RETURNS: void =>Turn on or off entity minimap indicator. The default is enabled. 
UI_EnableEntitySelectionVisuals( Entity * entity, bool enabled ) RETURNS: void =>Turn on or off entity selection visuals. The default is visuals enabled. 
UI_EnableSquadDecorator( Squad * squad, bool enabled ) RETURNS: void =>Turn on or off squad decorator. The default is decorator enabled. 
UI_EnableSquadMinimapIndicator( Squad * squad, bool enabled ) RETURNS: void =>Turn on or off squad minimap indicator. The default is enabled. 
UI_GetAbilityIconName( ScarAbilityPBG abilityBag ) RETURNS: const char * =>Returns the icon name for a given ability. 
UI_HighlightSGroup( SGroupID sgroup, Real duration ) RETURNS: Void =>Highlights an SGroup in the UI for the given duration. 
UI_SetAllowLoadAndSave( bool allowLoadAndSave ) RETURNS: void =>Enables or disable load and save features at the pause menu. 
UI_SetSGroupSpecialLevel( SGroup sgroup, Int level ) RETURNS: Void =>Sets a level decorator that's defined in all of the squads squad_ui_ext in the target SGroup. 
Util_AddMouseoverSquadToSGroup( Boolean clearGroup ) RETURNS: SGroupID =>If there's a squad under the mouse cursor, this adds it to a unique SGroup. Return value is the SGroup it was added to, or nil if there was no squad under the mouse cursor. Pass in true for 'clearGroup' to clear the sgroup before adding the squad. 
Util_ApplyModifier( SGroupID/EGroupID/Player groupid, String modifier, Real scalefactor, Real mathtype, Real applytype, Bool exclusive, String targetname ) RETURNS: ModID =>Applies any modifier to the target SGroup, EGroup, or Player. 
Util_AutoAmbient( Table intelEventTable ) RETURNS: Void =>Auto-generate an Ambient Event. These are Low priority, and will hopefully interrupt nothing. 
Util_AutoIntel( Table intelEventTable ) RETURNS: Void =>Auto-generate an Intel Event. These are medium priority, and will interrupt ambient, but not an NIS. 
Util_AutoNISlet( Integer nisletType, Table intelEventTable, boolean bFOWvisible ) RETURNS: Void =>Auto-generate an NISlet Event, a simple NIS meant to convey mission location. These are high priority, and will interrupt ambient and Intel Events. 
Util_Autosave( LocString checkpoint, Float delay, Boolean noFade ) RETURNS: void =>Automatically save the game for the player. The savegame name is built using the abbreviated mission name + checkpoint. 
Util_ClearWrecksFromMarker( MarkerID/Pos/SectorID position, Real range, Table wrecksList ) RETURNS: Void =>Clears vehicle wrecks from a given area. 
Util_DespawnAll( Boolean despawn, Boolean allPlayers or Int playerNum, Boolean egroups ) RETURNS: Void =>ReSpawns or DeSpawns sgroups (and egroups) for all players or the indicated player. 
Util_DifVar( Table difficultyVariables, Integer difficulty ) RETURNS: Variable =>Takes in a table and chooses the right variable for the difficulty setting. 1-4 elements. Acquires current difficulty by default. 
Util_ElementCanSee( PlayerID/TeamID playerID/ teamID, SGroupID/EGroupID/EntityID/SquadID/MarkerID/Position element, ALL  ) RETURNS: Boolean =>Returns true if a Player/Team can see any or all of an SGroup/Squad/EGroup/Entity/Position/Marker. 
Util_EntityLimit( Integer entityLimit ) RETURNS: Boolean =>Checks the entity count for the world and returns true or false depending on the result. A specific value can be passed in to override the default amount. 
Util_FallBackToGarrisonBuilding( SGroupID sgroupid, Int radius ) RETURNS: EntityID =>Try to garrison a loadable building within radius that is closer to the first squad of the sgroup than enemy. 
Util_FindHiddenItem( Position/EGroup/Entity/SGroup/Squad items ) RETURNS: Position EGroup Entity SGroup Squad =>Finds a hidden position based on what the local player can and can't see. 
Util_FindHiddenSpawn( Position origin, Position destination ) RETURNS: Position =>Finds a hidden position within the FOW between two given points. 
Util_ForceRetreatAll( SGroup sgroup, Marker marker, Marker , deleteAtMarker , Bool/AIEncounter aiEncounterDisable ) RETURNS: Void =>Forces all squads given to retreat, regardless of whether they are on team weapons or not. Disables aiEncounters input (true disables all encounters). 
Util_GarrisonNearbyBuilding( SGroupID sgroup, Position pos, Real radius, Boolean occupied, SGroup/Table filter ) RETURNS: EntityID =>Finds a nearby building to garrison. can ignore occupied [friendly] buildings. return ID of entity it found, or nil if not found. 
Util_GarrisonNearbyVehicle( SGroupID sgroup, Position pos, Real radius, Boolean occupied, SGroup/Table filter ) RETURNS: SquadID =>Finds a nearby vehicle to garrison. can ignore occupied [friendly] vehicles. return ID of vehicle it found, or nil if not found,. 
Util_GetClosestMarker( Variable var, Table markers ) RETURNS: MarkerID =>Returns the closest MarkerID to the entity/marker/pos/egroup/sgroup/squad from the table of markers provided. 
Util_GetEntitiesByBP( EGroupID sourcegroup, EGroupID destgroup, EntityBlueprint ebp ) RETURNS: Void =>Find all the entities with a given blueprint in sourcegroup and add them to destgroup. 
Util_GetHealth( Squad/Entity/Sgroup/Egroup var ) RETURNS: Percentage =>Determines the health percentage of a given object. 
Util_GetMouseoverSGroup( UnknownType  ) RETURNS: Void =>Returns a unique SGroup used to hold mouseover squads obtained from Util_AddMouseoverSquadToSGroup. 
Util_GetPosition( Variable var ) RETURNS: Position =>Returns a position from entity/marker/pos/egroup/sgroup/squad. 
Util_GetPositionAwayFromPlayer( MarkerID/Pos/EGroupID/SGroupID pos, PlayerID player, Integer searchRadius, Integer distance ) RETURNS: Position =>Returns a random position within an area that is not near a player. 
Util_GetPositionFromAtoB( MarkerID/Pos a, MarkerID/Pos b, Real distance ) RETURNS: Position =>Returns a position that is distance metres from point A, headed in the direction of point B. 
Util_GetRandomHiddenPosition( Position/EGroup/Entity/SGroup/Squad items ) RETURNS: Position EGroup Entity SGroup Squad =>Finds a hidden position based on what the local player can and can't see. 
Util_GetRandomPosition( MarkerID/ ScarPos, Real range, Boolean hidden ) RETURNS: Pos =>Returns a random position either within the marker's proximity or with a pos and range provided. Range is ignored for rectangular markers. 
Util_GetSquadsByBP( SGroupID sourcegroup, SGroupID destgroup, SquadBlueprint sbp ) RETURNS: Void =>Find all the squads with a given blueprint in sourcegroup and add them to destgroup. 
Util_GetTrailingNumber( String val ) RETURNS: Number =>Returns trailing numbers from a string, if it exists, nil otherwise. E.G. "marker23" would return 23. 
Util_Grab( Boolean subselect ) RETURNS: Sgroup Egroup =>Grabs the selected squads/entities and returns them in a group. Only works with -dev. 
Util_HasPosition( Variable var ) RETURNS: Boolean =>Returns true if given entity/marker/pos/egroup/sgroup/squad has a position; if false, Util_GetPosition will fail. 
Util_HidePlayerForNIS( PlayerID player, Bool hide ) RETURNS: Void =>Hides all of a player's squads and/or buildings. 
Util_IsSequenceSkipped( UnknownType  ) RETURNS: bool =>Returns whether the currently running sequence has been skipped. 
Util_Kill( Player/Squad/Entity/Sgroup/Egroup var ) RETURNS: Void =>Kills a given object. 
Util_LogSyncWpn( SGroupID syncweapon, Boolean kill ) RETURNS: Void =>Tracks a syncweapon ID and destroys it (by default) or makes it uncapturable (if kill is set to false) 
Util_MarkerFX( String markername, String eventfile ) RETURNS: void =>Play an events file at a given markers location. 
Util_MissionTitle( LocString title, Int time_fade_in, Int lifetime, Int time_fade_out ) RETURNS: Void =>Play the mission title fade. 
Util_MuteAmbientSound( Boolean enable, Real fade ) RETURNS: Void =>Enabling this function will mute the ambient sound (NOT all sound). 
Util_NewHUDFeatureEvent( HUDFeatureType newHUDFeature, LocString featureText, String featureIcon, Real duration ) RETURNS: void =>Calls UI_NewHUDFeature() as an IntelEvent. Will get queued as any other event. See UI_NewHUDFeature() for parameter details. 
Util_PlayMovie( String name, Integer fadeOut, Integer fadeIn, LuaFunction onComplete, Integer delay, Boolean onCompleteAfterMovie ) RETURNS: Void =>Play a movie. 
Util_PlayMusic( String name, Real fade, Real delay ) RETURNS: Void =>Plays music from the Data:Sound folder, and stores the music track so it can be resumed after a save/load  The new music will phase out the old one. There can only be one music playing at anytime besides the transition fade is the time to fade in the music; delay is the time in seconds to wait until the new music is started. Example: Sound_PlayMusic( "Music/GreatMusic", 0.0, 0.0 ) 
Util_PrintObject( Object obj, Int max_depth, String data_type, Function print_func ) RETURNS: Void =>Prints out the entire contents of an Object. 
Util_ReinforceEvent( SGroupID sgroupName, LocID custumTitle, LocID customDescript ) RETURNS: Void =>Creates an Event Cue for an SGroup and repeats it until the SGroup is killed or selected. 
Util_ReloadScript( UnknownType  ) RETURNS: Void =>Reloads the running scar script. Current running rules would also be updated to the redefined functioin. 
Util_RestoreMusic( Void  ) RETURNS: Void =>Resumes playing the music track that was last triggered i.e. after a save/load. 
Util_SetPlayerCanSkipSequence( LuaFunction event, LuaFunction skippedCallback, bool noFadeIn, int fadeInTime ) RETURNS: Void =>Sets it so that a player can skip a scripted sequence. When the skip key is pressed, calls back the given function as a post-sequence setup. noFadeIn stops the system from fading back into gameplay when finished. Call Util_SetPlayerUnableToSkipSequence() when the sequence is finished to disable. 
Util_SetPlayerUnableToSkipSequence( LuaFunction event, LuaFunction skippedCallback, bool noFadeIn ) RETURNS: Void =>Disables Util_SetPlayerCanSkipSequence. 
Util_SortPositionsByClosest( SGroupID/EGroupID/EntityID/SquadID/MarkerID/Position origin, Table positions, reverse  ) RETURNS: Table =>Returns a table of positions sorted from closest to furthest (or furthes to closest if reverse is true) from the origin. 
Util_StartAmbient( LuaFunction func ) RETURNS: Void =>Play a Speech Ambient. These are the lowest priority, and will be bumped by Intel Events or NIS's. 
Util_StartIntel( LuaFunction func ) RETURNS: Void =>Play an Intel Event. These are medium priority, and will interrupt a ambient, but not an NIS. 
Util_StartNislet( LuaFunction event, LuaFunction skippedCallback, bool noFadeIn, int fadeInTime ) RETURNS: Void =>Play Nislet Event. Starts a Nislet event, and calls back a function for post-nislet setup if the Nislet is skipped. noFadeIn stops the system from fading back into gameplay when the player skips. 
Util_StartQuickIntel( String actor, LocString speech ) RETURNS: Void =>Play a quick, one-line Intel event. These are medium priority, and will interrupt ambient, but not an NIS. 
Util_TableContains( Table targetTable, Object obj ) RETURNS: Boolean =>Checks the first layer of a table and looks for a specified Object, returns true if found. 
Util_ToggleAllowIntelEvents( UnknownType  ) RETURNS: void =>Debug function used to toggle whether or not IntelEvents are played. Only works with -dev parameter. 
Util_TriggerEvent( PlayerID playerid, Marker/EGroup/SGroup/ScarPos position, Int range, LuaFunction func, Boolean non_combat, Boolean onscreen_only, Int onscreen_duration ) RETURNS: Void =>Library function to trigger NIS event under a certain sets of conditions. NOTE: if checking against a marker DO NOT specify a range. The range of the marker set in the WorldBuilder will be used. 
Util_UnitCounts( Boolean world OR playerID player ) RETURNS: Lua =>Returns a table containing either the total or a specific player's squad count, entity count, and vehicle count. 
WaveManager_CheckWaveIsValid( Integer/Table waveManagerTableID/ waveManagerTable, Integer waveDataTableID ) RETURNS: Table =>Returns whether a specified wave table index is valid. 
WaveManager_ClearWaveManager( Void  ) RETURNS: Void =>WARNING! Clears the ENTIRE WaveManager table. 
WaveManager_FinishWave( Integer waveManagerTableID ) RETURNS: Void =>Forces the current wave to end. 
WaveManager_GetActiveEncountersCount( Integer waveManagerTableID ) RETURNS: Integer =>Returns the Total Active Encounters. 
WaveManager_GetAutomation( Integer waveManagerTableID ) RETURNS: Boolean =>Returns whether a Wave Manager Table is automated or not. 
WaveManager_GetCommandSGroup( Integer waveManagerTableID ) RETURNS: SGroup =>Gets a Wave Manager Command SGroup. 
WaveManager_GetCompletionData( Integer waveManagerTableID, Integer waveDataTableID ) RETURNS: Table =>Gets a Wave Manager Completion Data Table. 
WaveManager_GetEventsTable( Integer waveManagerTableID ) RETURNS: Table =>Gets a Wave Manager Event Table. 
WaveManager_GetManagerTable( Integer waveManagerTableID ) RETURNS: Table =>Returns a Wave Manager Table based on the ID. 
WaveManager_GetTotalWaves( Integer waveManagerTableID ) RETURNS: Integer =>Returns the Total Waves. 
WaveManager_GetVehicleSGroup( Integer waveManagerTableID ) RETURNS: SGroup =>Gets a Wave Manager Vehicle SGroup. 
WaveManager_GetWave( Integer waveManagerTableID ) RETURNS: Integer =>Returns the current Wave. 
WaveManager_GetWaveDataTable( Integer/Table waveManagerTableID/ waveManagerTable, Integer waveDataTableID ) RETURNS: Table =>Returns a Wave Data Table based off a Manager. 
WaveManager_LastWave( Integer waveManagerTableID, Boolean finishCurrentWave ) RETURNS: Void =>Return to the Previous Wave. 
WaveManager_NextWave( Integer waveManagerTableID, Boolean finishCurrentWave ) RETURNS: Void =>Advance to the Next Wave. 
WaveManager_RemoveWaveManager( Integer waveManagerTableID ) RETURNS: Void =>Removes a Wave Manager Table from the Wave Manager. 
WaveManager_ResetGoals( Integer waveManagerTableID ) RETURNS: Void =>Restarts all goals for the Wave Manager Data Table . 
WaveManager_SelectSpawns( Integer waveManagerTableID ) RETURNS: Void =>Tells a Wave Manager Table to select spawns. 
WaveManager_SetAutomation( Integer waveManagerTableID, Boolean automated ) RETURNS: Void =>Sets a Wave Manager Table to be automated or not. 
WaveManager_SetCoreWaveManagerData( Integer waveManagerTableID, Table newWaveManagerTable ) RETURNS: Void =>Used to update any portion of the required entries for a Wave Manager Table. 
WaveManager_SetupNewManagerTable( Table waveManagerTable, Boolean automated ) RETURNS: Integer =>Create a new Wave Manager Table and insert it into the manager. Can set the Manager to be automated (Must still be activated) 
WaveManager_SetWave( Integer waveManagerTableID, Integer newWave, Boolean finishCurrentWave ) RETURNS: Void =>Jump to a specific Wave. 
WaveManager_SpawnWave( Integer waveManagerTableID ) RETURNS: Void =>Tells a Wave Manager Table to spawn the current wave. 
WaveManager_Start( Integer waveManagerTableID ) RETURNS: Void =>Starts the WaveManager if it's automation is enabled. 
WaveManager_UpdateMainGoalData( Integer waveManagerTableID, Table newGoalData, Integer waveDataTableID ) RETURNS: Void =>Sets a Wave Manager Main Goal Data . 
Weather_SetType( const char * weatherLevelName ) RETURNS: void =>changes the weather state of all objects (options: sunny, lightrain, mediumrain, heavyrain) 
WinWarning_PublishLoseReminder( ModPlayer * player, long warningLevel ) RETURNS: void =>Triggers a UI event cue and an audio cue that the player is about to lose the game. 
WinWarning_ScoreDisplayIconAdd( const char * icon, int red, int green, int blue, int alpha, LocString tooltipName, LocString tooltipHelp, const char * tooltipIcon ) RETURNS: void =>Clears the icons for iconographic score cards. 
WinWarning_ScoreDisplayIconsClear(  ) RETURNS: void =>Clears the icons for iconographic score cards. 
WinWarning_SetCritical( bool team1Critical, bool team2Critical ) RETURNS: void =>Flash the victory point scores. 
WinWarning_SetMaxTickers( int team1MaxTickers, int team2MaxTickers ) RETURNS: void =>Sets the max victory point scores for the game. 
WinWarning_SetTickers( int team1Tickers, int team2Tickers ) RETURNS: void =>Sets the victory point scores for the game. 
WinWarning_SetToolTip( int teamIndex, LocString name, LocString help, const char * icon ) RETURNS: void =>Sets the tooltip for the victory point score card. 
WinWarning_ShowLoseWarning( LocString text, float fadeIn, float duration, float fadeOut ) RETURNS: uint32_t =>
World_AddPilferLockArea( ScarPosition pos, float radius ) RETURNS: void =>Add an area where pilferable weapons won't disappear due to timeout. 
World_CleanUpTheDead( PlayerID player ) RETURNS: Void =>Kill off a specific player's dead bodies (enter ALL to clean them all up) 
World_ClearCasualties(  ) RETURNS: void =>up casualties from the world 
World_DamageIce( ScarPosition pos, float innerRadius, float outerRadius, float innerDamage, float outerDamage ) RETURNS: void =>Damage a circle of ice with a gradient. 
World_DestroyWallsNearMarker( ScarMarker marker ) RETURNS: void =>Destroys walls (entities with a wall_ext) near a marker. 
World_DistanceEGroupToPoint( EGroup * egroup, ScarPosition p1, bool closest ) RETURNS: float =>Get the distance between a squad group and a point. 
World_DistancePointToPoint( ScarPosition p1, ScarPosition p2 ) RETURNS: float =>Get the distance between two points. 
World_DistanceSGroupToPoint( SGroup * sgroup, ScarPosition p1, bool closest ) RETURNS: float =>Get the distance between a squad group and a point. 
World_DistanceSquaredPointToPoint( ScarPosition p1, ScarPosition p2 ) RETURNS: float =>Get the distance squared between two points. 
World_EnableReplacementObjectForEmptyPlayers( bool enable ) RETURNS: void =>*** You must call this from OnGameSetup, otherwise it's too late *** Determines whether empty players get converted to null resource points. 
World_EnableSharedLineOfSight( ModPlayer * p0, ModPlayer * p1, bool enable ) RETURNS: void =>Enables or disables shared line of sight between these two players. 
World_EndSP( bool win ) RETURNS: void =>Wins/loses a single team mission for the local teams. 
World_GetClosest( Variable var, LuaTable items ) RETURNS: Variable =>Returns the closest object from the table of marker/pos/egroup/sgroup to the closest marker/pos/egroup/sgroup specified. 
World_GetCurrentInteractionStage(  ) RETURNS: int =>Returns the current interaction stage (areas painted at this number or lower are currently interactable) 
World_GetEntitiesNearMarker( Player * player, EGroup * egroup, ScarMarker marker, OwnerType ownerType ) RETURNS: int =>Find and add entities near the marker to the egroup. 
World_GetEntitiesNearPoint( Player * player, EGroup * egroup, ScarPosition pos, float radius, OwnerType ownerType ) RETURNS: int =>Find and add entities near the point to the egroup. 
World_GetEntitiesWithinTerritorySector( Player * player, EGroup * egroup, size_t sectorID, OwnerType ownerType ) RETURNS: int =>Find and add entities within the territory sector to the egroup. 
World_GetEntity( int index ) RETURNS: Entity * =>Returns the UniqueID at given index, use with World_GetNumEntities() to iterate through all the entities in the world. 
World_GetFurthest( Variable var, LuaTable items ) RETURNS: Variable =>Returns the furthest object from the table of marker/pos/egroup/sgroup to the furthest marker/pos/egroup/sgroup specified. 
World_GetGameTime(  ) RETURNS: float =>Return the total game time in seconds. 
World_GetHeightAt( float x, float y ) RETURNS: float =>returns the height of ground at 2D pos x,y 
World_GetHiddenPositionOnPath( PlayerID player, MarkerID/Pos origin, MarkerID/Pos destination, Integer checktype ) RETURNS: Position =>Find a position on a path hidden from view, as close to the destination as possible whilst still satisfying your hidden checktype. Checktype can be either CHECK_IN_FOW, CHECK_OFFCAMERA or CHECK_BOTH. 
World_GetLength(  ) RETURNS: float =>Returns the total playable length of the game world (z coordinate) 
World_GetNearestInteractablePoint( ScarPosition position ) RETURNS: ScarPosition =>returns the nearest intractable position to the supplied position 
World_GetNeutralEntitiesNearMarker( EGroup * egroup, ScarMarker marker ) RETURNS: int =>Find and add neutral entities near the marker to the egroup. 
World_GetNeutralEntitiesNearPoint( EGroup * egroup, ScarPosition pos, float radius ) RETURNS: int =>Find and add neutral entities near the point to the egroup. 
World_GetNeutralEntitiesWithinTerritorySector( EGroup * egroup, size_t sectorID ) RETURNS: int =>Find and add neutral entities within the territory sector to the egroup. 
World_GetNumEntities(  ) RETURNS: int =>Returns the number of spawned entities in the entire world (use sparingly and never at runtime) 
World_GetNumEntitiesNearPoint( ScarEntityPBG ebp, ScarPosition pos, float radius ) RETURNS: int =>Return the number of entities of the same ebp in the sphere volume. 
World_GetNumStrategicPoints(  ) RETURNS: int =>Returns the number of strategic points on this map (does not count strat. objectives) 
World_GetNumVictoryPoints(  ) RETURNS: int =>Returns the number of strategic objectives on this map. 
World_GetOffsetPosition( ScarPosition position, ScarPosition heading, int offset, float distance ) RETURNS: ScarPosition =>Returns a position that is offset a certain distance from the position/heading passed in. see ScarUtil.scar for explanation of 'offset' parameter. 
World_GetPlayerAt( uint32_t index ) RETURNS: Player * =>Returns the player at a given index, numbers start at one 
World_GetPlayerCount(  ) RETURNS: int =>Return the total number of players in the world. 
World_GetPlayerIndex( Player * player ) RETURNS: int =>Returns the player index given the Player* 
World_GetPossibleSquadsBlueprint( ScarRacePBG racePBG, int index ) RETURNS: ScarSquadPBG =>Returns the blueprint of a chosen squad for a race. 
World_GetPossibleSquadsCount( ScarRacePBG racePBG ) RETURNS: int =>Returns the number of types of squads a race can build. 
World_GetRaceBlueprint( const char * racename ) RETURNS: ScarRacePBG =>Returns the race index of a race, given its name (from the ME). 
World_GetRand( int min, int max ) RETURNS: int =>Returns a random integer with range [min, max]. 
World_GetSpawnablePosition( ScarPosition around, Entity * entity ) RETURNS: ScarPosition =>Given any position in the world, this function will return position safe for spawning a given entity. 
World_GetSquadsNearMarker( Player * player, SGroup * sgroup, ScarMarker marker, OwnerType ownerType ) RETURNS: int =>Find and add squads near the marker to the sgroup. 
World_GetSquadsNearPoint( Player * player, SGroup * sgroup, ScarPosition pos, float radius, OwnerType ownerType ) RETURNS: int =>Find and add squads near the point to the sgroup. 
World_GetSquadsWithinTerritorySector( Player * player, SGroup * sgroup, size_t sectorID, OwnerType ownerType ) RETURNS: int =>Find and add squads within territory sector identified by sector ID. 
World_GetStrategyPoints( EGroup * group, bool bIncludeVP ) RETURNS: void =>Appends all the strategic resource points to an egroup. 
World_GetTeamTerritoryGaps( int sectorid1, int sectorid2, LuaBinding::StackVarTable results ) RETURNS: bool =>Returns one or more sector IDs that would connect two unconnected pieces of territory. return value is through a table (since there can be more than one way to connect territory) - each entry in this table is a table of sector IDs. 
World_GetTeamVictoryTicker( int teamID ) RETURNS: int =>Returns the number of tickets that this team has. 
World_GetTerritorySectorID( ScarPosition pos ) RETURNS: size_t =>Return the sector ID from the position. 
World_GetTerritorySectorPosition( int sectorID ) RETURNS: ScarPosition =>Returns the position of a sector based on the capture entity (ex: the fuel point's position) 
World_GetWidth(  ) RETURNS: float =>Returns the total playable width of the game world (x coordinate) 
World_IncreaseInteractionStage(  ) RETURNS: void =>Increases current interaction stage by 1. 
World_IsGameOver(  ) RETURNS: bool =>to document 
World_IsInSupply( const ModPlayer * player, ScarPosition pos ) RETURNS: bool =>Returns true if position is in-supply for the given player. 
World_IsPointInPlayerTerritory( Player * player, ScarPosition position ) RETURNS: bool =>Returns true if position if part of the entity territory. 
World_IsReplay(  ) RETURNS: bool =>Returns TRUE if the game is currently in a replay state. 
World_IsTerritorySectorOwnedByPlayer( Player * player, size_t sectorID ) RETURNS: bool =>Find if player has ownership to this territory sector. 
World_IsWinterMap( UnknownType  ) RETURNS: Boolean =>Returns whether the current map is set in winter. Checks if 'g_isWinterMap' is set to true. 
World_KillAllNeutralEntitesNearMarker( MarkerID marker ) RETURNS: Void =>Kills ALL world entities near a marker. 
World_OwnsEGroup( EGroupID egroup, Boolean all ) RETURNS: Boolean =>Returns whether ANY or ALL of the entities in the group are owned by the world (i.e. neutral) 
World_OwnsEntity( Entity * entity ) RETURNS: bool =>Returns true if the squad is owned by the world. 
World_OwnsSGroup( SGroupID sgroup, Boolean all ) RETURNS: Boolean =>Returns whether ANY or ALL of the squads in the group are owned by the world (i.e. neutral) 
World_OwnsSquad( Squad * squad ) RETURNS: bool =>Returns true if the squad is owned by the world. 
World_PointPointProx( ScarPosition p1, ScarPosition p2, float prox ) RETURNS: bool =>Returns true if two world positions are in proximity to each other. 
World_Pos( float x, float y, float z ) RETURNS: ScarPosition =>Creates a new Position object. 
World_RemoveAllResourcePoints(  ) RETURNS: void =>Removes all resource and strategic points but not entities with a supply ext NOTE: this could eventually be written as - RemoveAllOfType( type ) which would be more flexible. 
World_RemovePilferLockArea( ScarPosition pos, float radius ) RETURNS: void =>Remove a locked pilfering area, must pass the same pos and radius as when the lock area was created. 
World_SetDesignerSupply( ScarPosition point, bool bSupply ) RETURNS: void =>Sets a particular sector in the world as a supply provider (or not) 
World_SetGameOver(  ) RETURNS: void =>to document 
World_SetIceHealingRate( float percentPerSecond ) RETURNS: void =>Set what percent ice heals per second (0.05 means 5% per second) 
World_SetPlayerLose( ModPlayer * player ) RETURNS: void =>Sets the player to a lose state, with a reason for losing, and kills the player. 
World_SetPlayerWin( ModPlayer * player ) RETURNS: void =>Sets the player and all the members allied to player to a win state, with a reason for winning. Also sets all other players to a lose state, and kills them (if they're not already dead) 
World_SetSnowHealingRate( float percentPerSecond ) RETURNS: void =>Set what percent snow heals per second (0.05 means 5% per second) 
World_SetTeamWin( int winningTeam ) RETURNS: void =>Sets every player on a team to a win state, with a reason for winning. Also sets all other players to a lose state, and kills them (if they're not already dead) 
World_SpawnDemolitionCharge( Player * player, ScarPosition pos ) RETURNS: bool =>spawn a demolitions charge at a position, 'player' is the one that owns the demolitions and can detonate them. 
World_TeamTerritoryPointsConnected( int team_index, ScarPosition p1, ScarPosition p2 ) RETURNS: bool =>Returns true if the two points are in the same territory region, and owned by the specified territory team, Returns false otherwise. 
XP1_AddCompanyStrength( Int strength, Bool announce ) RETURNS: Void =>Add to the current Company's strength. 
XP1_CommanderPortrait( UnknownType  ) RETURNS: ActorID =>Returns the actor ID for the company that is currently active. 
XP1_CompanyDif( Table companyVariables ) RETURNS: Variable =>Takes in a table and chooses the right variable for the current chosen company setting. CD_AIRBORNE, CD_MECHANIZED, CD_SUPPORT, CD_RANGER. 
XP1_ConstructCompanySpeechTable( String intelEventName ) RETURNS: Table =>Util function for constructing the data-table needed by XP1_PlayCompanySpeechLine. It requires a STRICT naming convention of intelEvent functions: <intelEventName>_<companyNAME>. Eg. EVENTS.MissionIntro_AIRBORNE. 
XP1_EncounterCreate( EncounterData data, Bool spawnNow, Bool spawnStaggered ) RETURNS: Encounter =>Wrapper function for creating an encounter. Randomly adds veterancy to enemy units based on XP1 campaign metamap node strength for the mission. If spawnNow is true, spawns specified units immediately. 
XP1_GetActualCompanyStrength( UnknownType  ) RETURNS: Int =>Return the current Company's Actual strength. 
XP1_GetCommanderDataTable( int CommanderDivision ) RETURNS: Void =>Returns the indicated commander's data table. If nil is passed, will return the current active commander. 
XP1_GetCompanyIcon( UnknownType  ) RETURNS: string =>Gets the current Company's Icon. 
XP1_GetCompanyLocName( UnknownType  ) RETURNS: Int =>Gets the current Company's Localized name. 
XP1_GetCompanyStrength( UnknownType  ) RETURNS: Int =>Return the current Company's strength [0-100]. 
XP1_GetDivision( UnknownType  ) RETURNS: String =>Gets the current Company (CD_AIRBORNE/CD_MECHANIZED/CD_SUPPORT). 
XP1_GetDivisionName( UnknownType  ) RETURNS: String =>Gets the current Company's name. 
XP1_GetMetaSubPhase( UnknownType  ) RETURNS: Int =>Returns the current metamap subphase (SUBPHASE_EARLY, SUBPHASE_MID, SUBPHASE_LATE) 
XP1_GetMissionSuccessLevel( UnknownType  ) RETURNS: Int =>Return the current MissionSuccessLevel [0-100]. 
XP1_GetNodeStrength( UnknownType  ) RETURNS: Int[1, 5] =>Returns the current node strength. 
XP1_GetNodeStrengthVeterancy( Void  ) RETURNS: Integer =>Randomly return a veterancy rank based on mission node strength, between 0-5. 
XP1_IncrementMissionSuccessLevel( int amount ) RETURNS: Void =>Adjusts the current mission success level by the amount provided (Mission Success Level is an int clamped between 0 and 3) 
XP1_IsCompanyAvailable( bool isCompanyActive ) RETURNS: Void =>Returns true if there is a company active. Used mainly to check if it's safe to alter stored data. 
XP1_NodeDif( Table nodeDifficultyVariables ) RETURNS: Variable =>Takes in a table and chooses the right variable for the current node strength setting. 1-5 elements. 
XP1_PlayCompanySpeechLine( Table commanderLines ) RETURNS: String =>Plays a line of speech dependant on your current active company. 
XP1_RemoveCompanyStrength( UnknownType newAmount, UnknownType announce ) RETURNS: Int =>Reduce the current Company's strength [0-100]. 
XP1_SetActiveCommander( int CommanderDivision, bool showUIDetails ) RETURNS: Void =>Sets the current commander (CD_AIRBORNE, CD_MECHANIZED, CD_SUPPORT). If nil is passed in, will re-set to the primary commander. Note this should be done behind a fade to black or something. 
XP1_SetActualCompanyStrength( Int strength ) RETURNS: Void =>Set the current Company's Actual strength. 
XP1_SetCompanyStrength( Int strength ) RETURNS: Void =>Set the current Company's strength [0-100]. 
XP1_SetMissionSuccessLevel( int newValue ) RETURNS: Void =>Sets the current mission success level to the amount provided (Mission Success Level is an int clamped between 0 and 100) 
XP1_ShowResults( Bool win ) RETURNS: Void =>Generates the output file read by XP1. 
XP1_StopCompanyStatTracking( UnknownType  ) RETURNS: Void =>Stop tracking all real-time changes in Company Strength and Experience. 

# ENUMS
